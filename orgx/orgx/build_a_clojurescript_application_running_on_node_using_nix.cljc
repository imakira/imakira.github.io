(ns orgx.build-a-clojurescript-application-running-on-node-using-nix (:require [uix.core :as uix :refer [defui use-state use-effect use-context $]] [net.coruscation.cerulean.utils :refer [cljc-case]] [net.coruscation.cerulean.common.components :refer [note info warn warning error tabs split-layout showcase]]))
(defui _comp [post-props] ($ :<> ($ :p {} "\nTo build a ClojureScript application, we need to pull dependencies from two package managers. That is, JavaScript packages from " ($ :code {} "npm") " and Clojure packages from " ($ :code {} "deps.edn") ". After pulling the dependencies, we can then let " ($ :code {} "shadow-cljs") " compiles the ClojureScript files into a single javascript and make the result a npm package. In this post, we rely on " ($ :code {} "nixpkgs") "'s builtin " ($ :code {} "fetchNpmDeps") " and " ($ :code {} "buildNpmPackage") " for the npm side, and " ($ :a {:href "https://github.com/jlesquembre/clj-nix"} "clj-nix") " for the nix side.\n") ($ note ($ :<> ($ :ul {:class "org-ul"} ($ :li {} ($ :b {} "changelog") "   Jan 17, 2026: use a new method to build the nix package, supports git repos, reduces output size.")))) ($ :div {:id "outline-container-prerequisites", :class "outline-2"} ($ :a {:href "#prerequisites"} ($ :h2 {:id "prerequisites", :class "cr-self-reference "} "Prerequisites")) ($ :div {:class "outline-text-2", :id "text-prerequisites"} ($ :p {} "\nI will skip the details that are not unique to Nix. The following contents assume we already have a working shadow-cljs project that can produce a node.js target when running " ($ :code {} "npm run release") ". Which is basically:\n") ($ :ul {:class "org-ul"} ($ :li {} "a " ($ :code {} ":node-script") " target in " ($ :code {} "shadow-cljs.edn") ", with " ($ :code {} ":main") " function specified") ($ :li {} "a " ($ :code {} "release") " script in package.json, most probably " ($ :code {} "shadow-cljs release script")) ($ :li {} "an entry script specified in " ($ :code {} "bin") " in package.json.")))) ($ :div {:id "outline-container-prefetch-and-generate-lock-file-for-dependencies", :class "outline-2"} ($ :a {:href "#prefetch-and-generate-lock-file-for-dependencies"} ($ :h2 {:id "prefetch-and-generate-lock-file-for-dependencies", :class "cr-self-reference "} "Prefetch and generate lock file for dependencies")) ($ :div {:class "outline-text-2", :id "text-prefetch-and-generate-lock-file-for-dependencies"} ($ :p {} "\nDuring the " ($ :i {} "build") " phase of nix package, the process cannot perform any network request, as that will defeat the whole point of " ($ :i {} "determinism") ". The common practice is to use a " ($ :i {} "lock file") ". Which is essentially a recipe of all the necessary resources (and their checksums) for the building process. We can then prefetch all the resources into the nix store and tell the building process where to find the necessary resources during the actual building.\n") ($ :p {} "\nOn the npm side, we do it by running the following command. It will output a sha256 code, we save it for later.\n") ($ :div {:class "org-src-container"} ($ :pre {:class "cr-highlighted"} ($ :code {:class "lang-bash"} "nix run nixpkgs#prefetch-npm-deps package-lock.json\n"))) ($ :p {} "\nOn the Clojure side, we execute the following command. It will generate a " ($ :code {} "deps-lock.json") " file. We will refer it in the " ($ :code {} "flake.nix") ".\n") ($ :div {:class "org-src-container"} ($ :pre {:class "cr-highlighted"} ($ :code {:class "lang-bash"} "nix run github:jlesquembre/clj-nix#deps-lock\n"))))) ($ :div {:id "outline-container-build-with-shadow-cljs-and-~mkcljlib~", :class "outline-2"} ($ :a {:href "#build-with-shadow-cljs-and-~mkcljlib~"} ($ :h2 {:id "build-with-shadow-cljs-and-~mkcljlib~", :class "cr-self-reference "} "Build with shadow-cljs and " ($ :code {} "mkCljLib"))) ($ :div {:class "outline-text-2", :id "text-build-with-shadow-cljs-and-~mkcljlib~"} ($ :p {} "\nWe need to add " ($ :code {} "clj-nix") "'s overlays to our flake.nix to be able to use " ($ :code {} "mkCljLib") ".\n") ($ :div {:class "org-src-container"} ($ :pre {:class "cr-highlighted"} ($ :code {:class "lang-nix"} "p" ($ :span {:class "hljs-attr"} "kgs") " " ($ :span {:class "hljs-operator"} "=") " " ($ :span {:class "hljs-built_in"} "import") " nixpkgs {\n  " ($ :span {:class "hljs-keyword"} "inherit") " system;\n  " ($ :span {:class "hljs-attr"} "overlays") " " ($ :span {:class "hljs-operator"} "=") " [\n    clj-nix.overlays.default\n  ];\n};\n"))) ($ :p {} "\nFirst, we create a " ($ :code {} "node_modules") " derivative which we will use later.\n") ($ :div {:class "org-src-container"} ($ :pre {:class "cr-highlighted"} ($ :code {:class "lang-nix"} "d" ($ :span {:class "hljs-attr"} "eps-hash") " " ($ :span {:class "hljs-operator"} "=") " " ($ :span {:class "hljs-string"} "\"deps-hash\"") ";\n\n" ($ :span {:class "hljs-attr"} "npm-deps") " " ($ :span {:class "hljs-operator"} "=") " pkgs.buildNpmPackage(" ($ :span {:class "hljs-params"} "finalAttrs:") " {\n  " ($ :span {:class "hljs-attr"} "src") " " ($ :span {:class "hljs-operator"} "=") " self;\n  " ($ :span {:class "hljs-attr"} "pname") " " ($ :span {:class "hljs-operator"} "=") " " ($ :span {:class "hljs-string"} "\"package-npm-deps\"") ";\n  " ($ :span {:class "hljs-attr"} "version") " " ($ :span {:class "hljs-operator"} "=") " " ($ :span {:class "hljs-string"} "\"0.0\"") ";\n  " ($ :span {:class "hljs-attr"} "dontNpmBuild") " " ($ :span {:class "hljs-operator"} "=") " " ($ :span {:class "hljs-literal"} "true") ";\n  " ($ :span {:class "hljs-attr"} "npmDepsHash") " " ($ :span {:class "hljs-operator"} "=") " deps-hash;\n  " ($ :span {:class "hljs-attr"} "installPhase") " " ($ :span {:class "hljs-operator"} "=") " " ($ :span {:class "hljs-string"} "''\n  mkdir $out\n  cp -r ./node_modules $out/node_modules\n  ''") ";\n});\n"))) ($ :p {} "\nWe will use " ($ :code {} "mkCljLib") " to setup Clojure dependencies for us, while we copy JavaScript dependencies from the earlier step manually.\n") ($ :div {:class "org-src-container"} ($ :pre {:class "cr-highlighted"} ($ :code {:class "lang-nix"} "b" ($ :span {:class "hljs-attr"} "uild") " " ($ :span {:class "hljs-operator"} "=") " pkgs.mkCljLib {\n  " ($ :span {:class "hljs-attr"} "projectSrc") " " ($ :span {:class "hljs-operator"} "=") " self;\n  " ($ :span {:class "hljs-attr"} "name") " " ($ :span {:class "hljs-operator"} "=") " " ($ :span {:class "hljs-string"} "\"espoir\"") ";\n  " ($ :span {:class "hljs-attr"} "buildCommand") " " ($ :span {:class "hljs-operator"} "=") " " ($ :span {:class "hljs-string"} "\"\n  # copy node_modules from earlier step to build directory\n  cp -r " ($ :span {:class "hljs-subst"} "${npm-deps}") "/node_modules ./node_modules\n  " ($ :span {:class "hljs-subst"} "${pkgs.nodejs}") "/bin/npm run release\n  \"") ";\n  " ($ :span {:class "hljs-attr"} "installPhase") " " ($ :span {:class "hljs-operator"} "=") " " ($ :span {:class "hljs-string"} "''\n  mkdir -p $out\n  cp -R * $out/\n  ''") ";\n};\n"))) ($ :p {} "\nIn the " ($ :code {} "buildCommand") ", we setup the JavaScript dependencies, and call " ($ :code {} "npm run release") " which in turn calls " ($ :code {} "shadow-cljs") " to build the project.\n") ($ :p {} "\nIn " ($ :code {} "installPhase") ", we override the install process provided by " ($ :code {} "mkCljLib") ". Instead, we simply use all the files in the build directory as output.\n"))) ($ :div {:id "outline-container-package-results-as-a-npm-package", :class "outline-2"} ($ :a {:href "#package-results-as-a-npm-package"} ($ :h2 {:id "package-results-as-a-npm-package", :class "cr-self-reference "} "Package results as a npm package")) ($ :div {:class "outline-text-2", :id "text-package-results-as-a-npm-package"} ($ :p {} "\nWe can directly feed output from the earlier example to " ($ :code {} "builNpmPackage") ". Since we already build the package, we will set " ($ :code {} "dontNpmBuild = true;") ".\n") ($ :p {} "\nThe install process provided by " ($ :code {} "buildNpmPackage") " will package necessary dependencies and generate an executable calling the entry script. \n") ($ :div {:class "org-src-container"} ($ :pre {:class "cr-highlighted"} ($ :code {:class "lang-nix"} "p" ($ :span {:class "hljs-attr"} "ackages.default") " " ($ :span {:class "hljs-operator"} "=") " pkgs.buildNpmPackage {\n  " ($ :span {:class "hljs-attr"} "pname") " " ($ :span {:class "hljs-operator"} "=") " " ($ :span {:class "hljs-string"} "\"espoir\"") ";\n  " ($ :span {:class "hljs-attr"} "src") " " ($ :span {:class "hljs-operator"} "=") " build;\n  " ($ :span {:class "hljs-attr"} "dontNpmBuild") " " ($ :span {:class "hljs-operator"} "=") " " ($ :span {:class "hljs-literal"} "true") ";\n  " ($ :span {:class "hljs-attr"} "version") " " ($ :span {:class "hljs-operator"} "=") " " ($ :span {:class "hljs-string"} "\"0.0.1\"") ";\n  " ($ :span {:class "hljs-attr"} "npmDepsHash") " " ($ :span {:class "hljs-operator"} "=") " deps-hash;\n};\n"))))) ($ :div {:id "outline-container-tips", :class "outline-2"} ($ :a {:href "#tips"} ($ :h2 {:id "tips", :class "cr-self-reference "} "Tips")) ($ :div {:class "outline-text-2", :id "text-tips"} ($ :ul {:class "org-ul"} ($ :li {} "Check " ($ :a {:href "https://github.com/imakira/espoir/blob/main/flake.nix"} "imakira/espoir/blob/main/flake.nix") " for a working example."))))))
(defui component [props] ($ _comp (merge (quote {:blog/orgx true, :blog/tags [], :blog/unlisted false, :blog/title "Build a ClojureScript Application Running on Node Using Nix", :blog/show-toc? true, :blog/file-path "/home/void/Projects/imakira.github.io/blogs/build-a-clojurescript-application-running-on-node-using-nix.org", :blog/author nil, :blog/email nil, :blog/description "To build a ClojureScript application, we need to pull dependencies from two package managers. That is, JavaScript packages from  npm  and Clojure packages ...", :blog/id "build-a-clojurescript-application-running-on-node-using-nix", :blog/category "Coding", :blog/language "en_US", :blog/published-date "2025-11-03T17:25:27+08:00", :blog/content "<p>\nTo build a ClojureScript application, we need to pull dependencies from two package managers. That is, JavaScript packages from <code>npm</code> and Clojure packages from <code>deps.edn</code>. After pulling the dependencies, we can then let <code>shadow-cljs</code> compiles the ClojureScript files into a single javascript and make the result a npm package. In this post, we rely on <code>nixpkgs</code>'s builtin <code>fetchNpmDeps</code> and <code>buildNpmPackage</code> for the npm side, and <a href=\"https://github.com/jlesquembre/clj-nix\">clj-nix</a> for the nix side.\n</p>\n\n<pre class=\"orgx\" data-wrapper=\"use-comp\" data-wrapper-data=\"note\"><ul class=\"org-ul\">\n<li><b>changelog</b>   Jan 17, 2026: use a new method to build the nix package, supports git repos, reduces output size.</li>\n</ul>\n\n</pre>\n<div id=\"outline-container-prerequisites\" class=\"outline-2\">\n<a href=\"#prerequisites\"><h2 id=\"prerequisites\" class=\"cr-self-reference \">Prerequisites</h2></a>\n<div class=\"outline-text-2\" id=\"text-prerequisites\">\n<p>\nI will skip the details that are not unique to Nix. The following contents assume we already have a working shadow-cljs project that can produce a node.js target when running <code>npm run release</code>. Which is basically:\n</p>\n\n<ul class=\"org-ul\">\n<li>a <code>:node-script</code> target in <code>shadow-cljs.edn</code>, with <code>:main</code> function specified</li>\n<li>a <code>release</code> script in package.json, most probably <code>shadow-cljs release script</code></li>\n<li>an entry script specified in <code>bin</code> in package.json.</li>\n</ul>\n</div>\n</div>\n<div id=\"outline-container-prefetch-and-generate-lock-file-for-dependencies\" class=\"outline-2\">\n<a href=\"#prefetch-and-generate-lock-file-for-dependencies\"><h2 id=\"prefetch-and-generate-lock-file-for-dependencies\" class=\"cr-self-reference \">Prefetch and generate lock file for dependencies</h2></a>\n<div class=\"outline-text-2\" id=\"text-prefetch-and-generate-lock-file-for-dependencies\">\n<p>\nDuring the <i>build</i> phase of nix package, the process cannot perform any network request, as that will defeat the whole point of <i>determinism</i>. The common practice is to use a <i>lock file</i>. Which is essentially a recipe of all the necessary resources (and their checksums) for the building process. We can then prefetch all the resources into the nix store and tell the building process where to find the necessary resources during the actual building.\n</p>\n\n<p>\nOn the npm side, we do it by running the following command. It will output a sha256 code, we save it for later.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-bash\"><html><head></head><body>nix run nixpkgs#prefetch-npm-deps package-lock.json\n</body></html></code></pre>\n</div>\n\n<p>\nOn the Clojure side, we execute the following command. It will generate a <code>deps-lock.json</code> file. We will refer it in the <code>flake.nix</code>.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-bash\"><html><head></head><body>nix run github:jlesquembre/clj-nix#deps-lock\n</body></html></code></pre>\n</div>\n</div>\n</div>\n<div id=\"outline-container-build-with-shadow-cljs-and-~mkcljlib~\" class=\"outline-2\">\n<a href=\"#build-with-shadow-cljs-and-~mkcljlib~\"><h2 id=\"build-with-shadow-cljs-and-~mkcljlib~\" class=\"cr-self-reference \">Build with shadow-cljs and <code>mkCljLib</code></h2></a>\n<div class=\"outline-text-2\" id=\"text-build-with-shadow-cljs-and-~mkcljlib~\">\n<p>\nWe need to add <code>clj-nix</code>'s overlays to our flake.nix to be able to use <code>mkCljLib</code>.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-nix\"><html><head></head><body>p<span class=\"hljs-attr\">kgs</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-built_in\">import</span> nixpkgs {\n  <span class=\"hljs-keyword\">inherit</span> system;\n  <span class=\"hljs-attr\">overlays</span> <span class=\"hljs-operator\">=</span> [\n    clj-nix.overlays.default\n  ];\n};\n</body></html></code></pre>\n</div>\n\n<p>\nFirst, we create a <code>node_modules</code> derivative which we will use later.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-nix\"><html><head></head><body>d<span class=\"hljs-attr\">eps-hash</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;deps-hash&quot;</span>;\n\n<span class=\"hljs-attr\">npm-deps</span> <span class=\"hljs-operator\">=</span> pkgs.buildNpmPackage(<span class=\"hljs-params\">finalAttrs:</span> {\n  <span class=\"hljs-attr\">src</span> <span class=\"hljs-operator\">=</span> self;\n  <span class=\"hljs-attr\">pname</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;package-npm-deps&quot;</span>;\n  <span class=\"hljs-attr\">version</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;0.0&quot;</span>;\n  <span class=\"hljs-attr\">dontNpmBuild</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span>;\n  <span class=\"hljs-attr\">npmDepsHash</span> <span class=\"hljs-operator\">=</span> deps-hash;\n  <span class=\"hljs-attr\">installPhase</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">''\n  mkdir $out\n  cp -r ./node_modules $out/node_modules\n  ''</span>;\n});\n</body></html></code></pre>\n</div>\n\n<p>\nWe will use <code>mkCljLib</code> to setup Clojure dependencies for us, while we copy JavaScript dependencies from the earlier step manually.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-nix\"><html><head></head><body>b<span class=\"hljs-attr\">uild</span> <span class=\"hljs-operator\">=</span> pkgs.mkCljLib {\n  <span class=\"hljs-attr\">projectSrc</span> <span class=\"hljs-operator\">=</span> self;\n  <span class=\"hljs-attr\">name</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;espoir&quot;</span>;\n  <span class=\"hljs-attr\">buildCommand</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;\n  # copy node_modules from earlier step to build directory\n  cp -r <span class=\"hljs-subst\">${npm-deps}</span>/node_modules ./node_modules\n  <span class=\"hljs-subst\">${pkgs.nodejs}</span>/bin/npm run release\n  &quot;</span>;\n  <span class=\"hljs-attr\">installPhase</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">''\n  mkdir -p $out\n  cp -R * $out/\n  ''</span>;\n};\n</body></html></code></pre>\n</div>\n\n<p>\nIn the <code>buildCommand</code>, we setup the JavaScript dependencies, and call <code>npm run release</code> which in turn calls <code>shadow-cljs</code> to build the project.\n</p>\n\n<p>\nIn <code>installPhase</code>, we override the install process provided by <code>mkCljLib</code>. Instead, we simply use all the files in the build directory as output.\n</p>\n</div>\n</div>\n<div id=\"outline-container-package-results-as-a-npm-package\" class=\"outline-2\">\n<a href=\"#package-results-as-a-npm-package\"><h2 id=\"package-results-as-a-npm-package\" class=\"cr-self-reference \">Package results as a npm package</h2></a>\n<div class=\"outline-text-2\" id=\"text-package-results-as-a-npm-package\">\n<p>\nWe can directly feed output from the earlier example to <code>builNpmPackage</code>. Since we already build the package, we will set <code>dontNpmBuild = true;</code>.\n</p>\n\n<p>\nThe install process provided by <code>buildNpmPackage</code> will package necessary dependencies and generate an executable calling the entry script. \n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-nix\"><html><head></head><body>p<span class=\"hljs-attr\">ackages.default</span> <span class=\"hljs-operator\">=</span> pkgs.buildNpmPackage {\n  <span class=\"hljs-attr\">pname</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;espoir&quot;</span>;\n  <span class=\"hljs-attr\">src</span> <span class=\"hljs-operator\">=</span> build;\n  <span class=\"hljs-attr\">dontNpmBuild</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span>;\n  <span class=\"hljs-attr\">version</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;0.0.1&quot;</span>;\n  <span class=\"hljs-attr\">npmDepsHash</span> <span class=\"hljs-operator\">=</span> deps-hash;\n};\n</body></html></code></pre>\n</div>\n</div>\n</div>\n<div id=\"outline-container-tips\" class=\"outline-2\">\n<a href=\"#tips\"><h2 id=\"tips\" class=\"cr-self-reference \">Tips</h2></a>\n<div class=\"outline-text-2\" id=\"text-tips\">\n<ul class=\"org-ul\">\n<li>Check <a href=\"https://github.com/imakira/espoir/blob/main/flake.nix\">imakira/espoir/blob/main/flake.nix</a> for a working example.</li>\n</ul>\n</div>\n</div>\n", :blog/orgx-require nil, :blog/modified-date "2026-01-17T17:39:46+08:00"}) props)))