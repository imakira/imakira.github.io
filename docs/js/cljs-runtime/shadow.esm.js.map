{"version":3,"sources":["shadow/esm.cljs"],"mappings":";;;AAcA;;;4BAAA,5BAAMA,gEAEHC;AAFH,AAGE,OAACC,kBAAqBD;;AAQxB,uBAAA,vBAAKE;AAEL,oBAAA,pBAAKC;AAEL,wBAAA,xBAAMC,wDAAYC;AAAlB,AACE,QAAeF,kBAAO,gDAAKE;;AAE7B,0BAAA,1BAAMC,4DAAcD;AAApB,AACE,IAAME,IAAE,gDAAKF;IACPG,OAAK,CAAeN,qBAAUK;AADpC,AAEE,oBAAUC;AAAV;AAAA,AACE,MAAO,KAAAC,MAAW,IAAA,iFAA0CF;;;AAE9D,IAAMG,aAAO,MAAA,LAAeF;IACtBG,WAAS,MAAA,LAAeH;AAD9B,OAGM,AAACT,0BAAe,IAAA,6DAAA,ZAAUW,tFAC1B,+GAAO,WAAKA;AAAL,AACE,CAAeP,kBAAOI,KAAEI;;AAExBA;;;AAKnB,0BAAA,1BAAOC,4DAAcP,SAASK,OAAOC;AAArC,AACE,2FAAA,nFAAeT,qBAAU,gDAAKG,0BAAwBK,eAAaC","names":["shadow.esm/dynamic-import","what","js/shadow_esm_import","shadow.esm/loadables","shadow.esm/loaded","shadow.esm/get-loaded","the-name","shadow.esm/load-by-name","s","info","js/Error","module","accessor","shadow.esm/add-loadable"],"sourcesContent":["(ns shadow.esm)\n\n;; workaround until we can tell the closure-compiler to not rewrite\n;; a dynamic import(). we just want to keep it as is to import \"foreign\"\n;; code dynamically at runtime.\n;; FIXME: can't use import as name apparantly?\n;;\n;; (ns foo (:require [shadow.esm :refer (import)]))\n;; (defn init []\n;;   (js/console.log (import \"./b.js\")))\n;; ------------------------- ^------------------------------------------------------\n;; Error in phase :compilation\n;; Arguments to import must be quoted. Offending spec: ./b.js at line 10 demo / esm/a.cljs\n;; --------------------------------------------------------------------------------\n(defn dynamic-import\n  \"dynamic import(path) where path is relative to the :output-dir of the build\"\n  [what]\n  (js/shadow_esm_import what))\n\n;; the compiler fills this with data after compilation, so that all vars marked\n;; as ^:lazy-loadable result calls to add-loadable appended to this file\n;; (shadow.esm/add-loadable \"the.fully.qualified/name\" \"foo\" (fn [] the.fully.qualified/name))\n;; we do all this because of the \"foo\" which represents the name of the module we need to load\n;; this means the user doesn't need to remember or change which module a given thing is in\n;; it uses an accessor function so that it can work with hot-reload and doesn't return outdated references\n(def loadables #js {})\n\n(def loaded #js {})\n\n(defn get-loaded [the-name]\n  (unchecked-get loaded (str the-name)))\n\n(defn load-by-name [the-name]\n  (let [s (str the-name)\n        info (unchecked-get loadables s)]\n    (when-not info\n      (throw (js/Error. (str \"could not find loadable info for: \" s))))\n\n    (let [module (unchecked-get info \"module\")\n          accessor (unchecked-get info \"get\")]\n\n      (-> (dynamic-import (str \"./\" module \".js\"))\n          (.then (fn [module]\n                   (unchecked-set loaded s accessor)\n                   ;; don't want to rely on module exports, makes config too verbose\n                   accessor))))))\n\n\n;; the compiler emits JS directly, and doesn't actually call this\n;; making it private just to people don't assume this is something they are supposed to call\n(defn- add-loadable [the-name module accessor]\n  (unchecked-set loadables (str the-name) #js {\"module\" module \"get\" accessor}))"],"x_google_ignoreList":[0]}