<!DOCTYPE html><html class="no-js" lang="en"><head><meta charset="utf-8" /><meta content="ie=edge" http-equiv="x-ua-compatible" /><meta content="A common challenge when making a fullstack website using Clojure/ClojureScript is that, we are often required to use a JavaScript library on the server sid..." name="description" /><meta content="width=device-width, initial-scale=1" name="viewport" /><title>Experiment with GraalVM, Clojure, and JavaScript | Coruscation.net</title><link href="https://fonts.googleapis.com" rel="preconnect" /><link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" /><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&amp;display=swap" rel="stylesheet" /><link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0&amp;icon_names=keyboard_arrow_down" rel="stylesheet" /><link href="/main.css?v=1769375442202" rel="stylesheet" /><link href="https://coruscation.net/atom.xml" rel="alternate" title="Coruscation.net" type="application/rss+xml" /><link href="/js/main.js" rel="modulepreload" /></head><body><div id="root"><div class="app h-dvh w-full xl:grid xl:grid-cols-[20rem_9fr]"><div class="transition-all"><div class="bg-opacity-100 px-4 relative bg-[#0260B3] sm:flex sm:justify-between block gap-4 xl:grid xl:grid-cols-[2fr_3fr] xl:h-dvh xl:fixed xl:w-[20rem]"><a class="flex justify-center block" href="/"><span class="text-3xl text-cyan-50 pt-4 sm:py-6 xl:sideways-lr xl:text-6xl xl:pb-8">Coruscation.net</span></a><div class="flex justify-center"><div class="flex flex-col items-center justify-end py-1 relative left-[0.275rem] sm:items-end xl:justify-between"><div class="navigator-bar gap-3 text-base text-slate-50 opacity-80 flex px-5 my-2 xl:text-2xl xl:flex-col xl:pt-6"><div class="px-1 group-hover:text-cyan-50 text-lg"><a href="/">HOME</a></div><div class="px-1 group-hover:text-cyan-50 text-lg"><a href="https://github.com/imakira">ABOUT</a></div><div class="px-1 group-hover:text-cyan-50 text-lg"><a href="https://github.com/imakira">PROJECTS</a></div></div><div class="justify-center w-full mb-8 relative hidden xl:flex"><div class="flex relative"><a href="/atom.xml"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" width="40" height="32">&lt;!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc. --&gt;<path d="M64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32zM96 136c0-13.3 10.7-24 24-24c137 0 248 111 248 248c0 13.3-10.7 24-24 24s-24-10.7-24-24c0-110.5-89.5-200-200-200c-13.3 0-24-10.7-24-24zm0 96c0-13.3 10.7-24 24-24c83.9 0 152 68.1 152 152c0 13.3-10.7 24-24 24s-24-10.7-24-24c0-57.4-46.6-104-104-104c-13.3 0-24-10.7-24-24zm0 120a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z"></path></svg></a><a href="https://github.com/imakira/cerulean"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512" width="40" height="32">&lt;!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc. --&gt;<path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a><a href=""><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" width="40" height="32">&lt;!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc. --&gt;<path d="M64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32zM218 271.7L64.2 172.4C66 156.4 79.5 144 96 144l256 0c16.5 0 30 12.4 31.8 28.4L230 271.7c-1.8 1.2-3.9 1.8-6 1.8s-4.2-.6-6-1.8zm29.4 26.9L384 210.4 384 336c0 17.7-14.3 32-32 32L96 368c-17.7 0-32-14.3-32-32l0-125.6 136.6 88.2c7 4.5 15.1 6.9 23.4 6.9s16.4-2.4 23.4-6.9z"></path></svg></a></div></div></div></div></div></div><main class="pt-5 px-2 sm:px-4 xl:pt-7 xl:px-8"><div class="px-4 relative"><div><h1 class="font-medium text-neutral-700 leading-tight text-2xl sm:text-[2rem]">Experiment with GraalVM, Clojure, and JavaScript</h1><hr class="border-t-1 border-slate-500 w-full my-3"/><div class="text-base grid items-center text-gray-700 pl-[1px] grid-cols-[7rem_1fr]"><div class="text-sky-700 border-l-2 pl-2 text-lg">Coding</div><span class="flex items-center gap-4"><span class="flex items-center gap-2"><span class="text-gray-600">Pub.</span><span class="text-base text-gray-700">Nov 18, 2025</span></span></span></div></div><div></div><input id="toc-mobile-control" class="hidden" type="checkbox"/><label class=" toc-header cursor-pointer select-none block text-sky-700 border-1 pl-2  flex justify-between items-center mt-3 bg-white sticky top-0 h-8 pr-1  md:hidden ml-[1px] relative " for="toc-mobile-control"><div class="relative h-full w-full overflow-hidden"><div class="text-lg toc-header-text relative  w-full transition-all "><div class="h-8 w-96">Table Of Content</div><div class="h-8 w-96 overflow-hidden">Basic Setup and a Hello World Program</div><div class="h-8 w-96 overflow-hidden">Working With JavaScript Libraries</div><div class="h-8 w-96 overflow-hidden">Ease Things With Helper Functions, Macros and More</div><div class="h-8 w-96 overflow-hidden">Mapping between Clojure and Polyglot Values</div><div class="h-8 w-96 overflow-hidden">Primitive Types</div><div class="h-8 w-96 overflow-hidden">Functions</div><div class="h-8 w-96 overflow-hidden">Objects</div><div class="h-8 w-96 overflow-hidden">Dot Macros and  set!</div><div class="h-8 w-96 overflow-hidden">require  command</div><div class="h-8 w-96 overflow-hidden">Bonus: Special  js  namespace</div><div class="h-8 w-96 overflow-hidden">Limitations</div><div class="h-8 w-96 overflow-hidden">Functionalities specific to an environment</div><div class="h-8 w-96 overflow-hidden">Multithreading and the  js  namespace</div><div class="h-8 w-96 overflow-hidden">Shorthands for dot macros</div><div class="h-8 w-96 overflow-hidden">Importing ECMAScript Modules</div><div class="h-8 w-96 overflow-hidden">Using JavaScript array in Clojure</div><div class="h-8 w-96 overflow-hidden">To Be Continue…</div></div></div><span class="material-symbols-outlined checked:rotate-180 transition-all dropdown-icon">keyboard_arrow_down</span></label><div class="toc-mobile-wrapper2 h-1 sticky top-8"><div class="grid toc-mobile-wrapper transition-all border-neutral-400 border-l-1 bg-white md:hidden ml-[1px] "><ul class="toc-mobile-content text-[1.05rem] 2xl:text-lg "><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-4" href="#basic-setup-and-a-hello-world-program"><span>Basic Setup and a Hello World Program</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-4" href="#working-with-javascript-libraries"><span>Working With JavaScript Libraries</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-4" href="#ease-things-with-helper-functions,-macros-and-more"><span>Ease Things With Helper Functions, Macros and More</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-8" href="#mapping-between-clojure-and-polyglot-values"><span>Mapping between Clojure and Polyglot Values</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-12" href="#primitive-types"><span>Primitive Types</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-12" href="#functions"><span>Functions</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-12" href="#mapping_objects"><span>Objects</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-8" href="#dot-macros-and-~set!~"><span>Dot Macros and  set!</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-8" href="#~require~-command"><span>require  command</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-8" href="#bonus:-special-~js~-namespace"><span>Bonus: Special  js  namespace</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-4" href="#limitations"><span>Limitations</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-8" href="#functionalities-specific-to-an-environment"><span>Functionalities specific to an environment</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-8" href="#multithreading-and-the-~js~-namespace"><span>Multithreading and the  js  namespace</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-8" href="#shorthands-for-dot-macros"><span>Shorthands for dot macros</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-8" href="#importing-ecmascript-modules"><span>Importing ECMAScript Modules</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-8" href="#using-javascript-array-in-clojure"><span>Using JavaScript array in Clojure</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-4" href="#to-be-continue..."><span>To Be Continue…</span></a></div></div></div></li></ul></div></div><div class="gap-8 w-full h-full md:grid md:grid-cols-[minmax(0px,7fr)_minmax(17rem,17rem)] 2xl:grid-cols-[minmax(0px,7fr)_minmax(20rem,20rem)]"><div class="cr-document md:mt-1"><p>
A common challenge when making a fullstack website using Clojure/ClojureScript is that, we are often required to use a JavaScript library on the server side when doing Server Side Rendering (SSR). GraalVM/GraalJS provides a solution to run JavaScript code on the JVM. If only we could harness that power…
</p>

<p>
This blog describes the basic usage of GraalJS and what I managed to achieve with GraalJS and Clojure.
</p>
<div id="outline-container-basic-setup-and-a-hello-world-program" class="outline-2">
<a href="#basic-setup-and-a-hello-world-program"><h2 id="basic-setup-and-a-hello-world-program" class="cr-self-reference ">Basic Setup and a Hello World Program</h2></a>
<div class="outline-text-2" id="text-basic-setup-and-a-hello-world-program">
<p>
We add the following dependencies to our <code>deps.edn</code>
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-bash"><html><head></head><body>:deps {org.clojure/clojure {:mvn/version <span class="hljs-string">&quot;1.11.1&quot;</span>}
       org.graalvm.polyglot/polyglot {:mvn/version <span class="hljs-string">&quot;25.0.1&quot;</span>}
       org.graalvm.js/js-language {:mvn/version <span class="hljs-string">&quot;25.0.1&quot;</span>}
       org.graalvm.truffle/truffle-runtime {:mvn/version <span class="hljs-string">&quot;25.0.1&quot;</span>}}
</body></html></code></pre>
</div>

<p>
With the dependencies installed, we can write a Hello World program.
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-name"><span class="hljs-built_in">ns</span></span> your-namespace
  (<span class="hljs-symbol">:import</span>
   [org.graalvm.polyglot Context]))


(<span class="hljs-keyword">defonce</span> ^<span class="hljs-symbol">:dynamic</span> <span class="hljs-title">*context*</span>
  (<span class="hljs-name"><span class="hljs-built_in">-&gt;</span></span> (<span class="hljs-name">Context/newBuilder</span> (<span class="hljs-name"><span class="hljs-built_in">into-array</span></span> String [<span class="hljs-string">&quot;js&quot;</span>]))
      (<span class="hljs-name">.build</span>)))

(<span class="hljs-keyword">def</span> <span class="hljs-title">hello-fn</span> (<span class="hljs-name">.eval</span> *context*
                     <span class="hljs-string">&quot;js&quot;</span>
                     <span class="hljs-string">&quot;(function (name) {console.log('hello '+name)})&quot;</span>))

(<span class="hljs-name">.executeVoid</span> hello-fn (<span class="hljs-name"><span class="hljs-built_in">into-array</span></span> String [<span class="hljs-string">&quot;world!&quot;</span>])) <span class="hljs-comment">;; output: hello world!</span>
</body></html></code></pre>
</div>

<p>
All kinds of JavaScript values are represented as <code>org.graalvm.polyglot.Value</code> objects by GraalJS. In the above example the <code>(.eval ...)</code> calling returns a executable <code>polyglot.Value</code>.
</p>

<p>
We can check if it is an executable by calling the <code>.canExecute()</code> method.
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-name">.canExecute</span> hello-fn) <span class="hljs-comment">;; true</span>
</body></html></code></pre>
</div>

<p>
We can invoke the executable by calling the <code>.execute()</code> method or the <code>.executeVoid()</code> method. Their difference is that latter one doesn't have a return value.
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-name">.executeVoid</span> hello-fn (<span class="hljs-name"><span class="hljs-built_in">into-array</span></span> Object [<span class="hljs-string">&quot;world&quot;</span>])) <span class="hljs-comment">;; output: hello world</span>

(<span class="hljs-name">.executeVoid</span> hello-fn (<span class="hljs-name"><span class="hljs-built_in">into-array</span></span> Object [<span class="hljs-string">&quot;graaljs&quot;</span>])) <span class="hljs-comment">;; output: hello graaljs</span>
</body></html></code></pre>
</div>

<p>
You can check if a <code>polyglot.Value</code> object is of a certain type by using methods starting with <code>.is</code>, and convert the <code>Value</code> object to native Java value with methods starting with <code>.as</code>. For example:
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-keyword">def</span> <span class="hljs-title">integer-one</span> (<span class="hljs-name">.eval</span> *context* <span class="hljs-string">&quot;js&quot;</span> <span class="hljs-string">&quot;1&quot;</span>)) <span class="hljs-comment">;; #object[org.graalvm.polyglot.Value 0x3583d830 &quot;1&quot;]</span>
(<span class="hljs-name">.isNumber</span> integer-one) <span class="hljs-comment">;; true</span>
(<span class="hljs-name">.asLong</span> integer-one) <span class="hljs-comment">;; 1</span>
(<span class="hljs-name">.isString</span> integer-one) <span class="hljs-comment">;; false</span>
(<span class="hljs-name">.asString</span> integer-one) <span class="hljs-comment">;; ERROR: Unhandled java.lang.ClassCastException</span>
</body></html></code></pre>
</div>

<p>
To handle JavaScript objects, we have <code>.newInstance()</code> for instantiating an Object, <code>.invokeMember()</code> for calling a method, <code>.getMemberKeys()</code>, <code>.getMember()</code> and <code>.putMember()</code> for accessing properties of an object.
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body><span class="hljs-comment">;; We can access top-level JavaScript variables using the (.getBindings *context* &quot;js&quot;).</span>
<span class="hljs-comment">;; It returns a polyglot.Value object from which we can retrieve builtin</span>
<span class="hljs-comment">;;   JavaScript functions and objects.</span>
(<span class="hljs-keyword">def</span> <span class="hljs-title">Array</span> (<span class="hljs-name">.getMember</span> (<span class="hljs-name">.getBindings</span> *context* <span class="hljs-string">&quot;js&quot;</span>) <span class="hljs-string">&quot;Array&quot;</span>))

<span class="hljs-comment">;; create an Array</span>
(<span class="hljs-keyword">def</span> <span class="hljs-title">arr</span> (<span class="hljs-name">.newInstance</span> Array (<span class="hljs-name"><span class="hljs-built_in">into-array</span></span> Object [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>])))

(<span class="hljs-name">print</span> arr) <span class="hljs-comment">;; #object[org.graalvm.polyglot.Value 0x2dd585ca &quot;(3)[1, 2, 3]&quot;]</span>

<span class="hljs-comment">;; pop a value and cast it to Long</span>
(<span class="hljs-name">.asLong</span> (<span class="hljs-name">.invokeMember</span> arr <span class="hljs-string">&quot;pop&quot;</span> (<span class="hljs-name"><span class="hljs-built_in">into-array</span></span> Object []))) <span class="hljs-comment">;; 3</span>

(<span class="hljs-name">print</span> arr) <span class="hljs-comment">;; #object[org.graalvm.polyglot.Value 0x27e1e162 (2)[1, 2]]</span>
</body></html></code></pre>
</div>
</div>
</div>
<div id="outline-container-working-with-javascript-libraries" class="outline-2">
<a href="#working-with-javascript-libraries"><h2 id="working-with-javascript-libraries" class="cr-self-reference ">Working With JavaScript Libraries</h2></a>
<div class="outline-text-2" id="text-working-with-javascript-libraries">
<p>
GraalJS has an option to provide a <code>require</code> function, with which we can import CommonJS JavaScript modules. The option isn't enabled by default. To enable it, we need to change the definition of <code>*context*</code> to the following:
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-keyword">defonce</span> ^<span class="hljs-symbol">:dynamic</span> <span class="hljs-title">*context*</span>
  (<span class="hljs-name"><span class="hljs-built_in">-&gt;</span></span> (<span class="hljs-name">Context/newBuilder</span> (<span class="hljs-name"><span class="hljs-built_in">into-array</span></span> String ))
      (<span class="hljs-name">.allowExperimentalOptions</span> <span class="hljs-literal">true</span>)
      (<span class="hljs-name">.options</span> (<span class="hljs-name">HashMap.</span>
                 {<span class="hljs-string">&quot;js.commonjs-require&quot;</span> <span class="hljs-string">&quot;true&quot;</span>
                  <span class="hljs-string">&quot;js.commonjs-require-cwd&quot;</span> (<span class="hljs-name"><span class="hljs-built_in">str</span></span> (<span class="hljs-name">System/getProperty</span> <span class="hljs-string">&quot;user.dir&quot;</span>)
                                                 <span class="hljs-string">&quot;/node_modules&quot;</span>)}))
      (<span class="hljs-name">.allowIO</span> <span class="hljs-literal">true</span>)
      (<span class="hljs-name">.build</span>)))
</body></html></code></pre>
</div>

<p>
Here we use as <code>commonjs-require-cwd</code>'s value. It tells GraalJS to find JavaScript modules under the <code>node_modules</code> folder in the project root.
</p>

<p>
We can then install JavaScript libraries using npm under the project root. Here I use &quot;luxon&quot; as an example.
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-bash"><html><head></head><body>npm init
npm install luxon
</body></html></code></pre>
</div>

<p>
We can then import the module by using <code>require</code> function.
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-keyword">def</span> <span class="hljs-title">luxon</span> (<span class="hljs-name">.eval</span> *context* <span class="hljs-string">&quot;js&quot;</span> <span class="hljs-string">&quot;require('luxon')&quot;</span>))
</body></html></code></pre>
</div>

<p>
We can access the resulting module with the <code>.getMember()</code> method.
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-keyword">def</span> <span class="hljs-title">DateTime</span> (<span class="hljs-name">.getMember</span> luxon <span class="hljs-string">&quot;DateTime&quot;</span>))
</body></html></code></pre>
</div>

<p>
Now we have the <code>DateTime</code> class from the <code>luxon</code> library, let's try to turn it into something useful:
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-keyword">defn</span> <span class="hljs-title">now</span> []
  (<span class="hljs-name"><span class="hljs-built_in">-&gt;</span></span> DateTime
      <span class="hljs-comment">;; DateTime.now() returns a DateTime object</span>
      (<span class="hljs-name">.invokeMember</span> <span class="hljs-string">&quot;now&quot;</span> (<span class="hljs-name"><span class="hljs-built_in">into-array</span></span> Object []))
      <span class="hljs-comment">;; We call the .toString method to convert the object</span>
      <span class="hljs-comment">;;    into a JavaScript String</span>
          (<span class="hljs-name">.invokeMember</span> <span class="hljs-string">&quot;toString&quot;</span> (<span class="hljs-name"><span class="hljs-built_in">into-array</span></span> Object []))
      <span class="hljs-comment">;; then we convert the result into a Java String</span>
          (<span class="hljs-name">.asString</span>)))

<span class="hljs-comment">;; Let's try to call the function</span>

(<span class="hljs-name">now</span>) <span class="hljs-comment">;; &quot;2025-11-15T16:56:49.798+08:00&quot;</span>
(<span class="hljs-name">now</span>) <span class="hljs-comment">;; &quot;2025-11-15T16:57:01.961+08:00&quot;</span>

</body></html></code></pre>
</div>

<p>
We wrapped the details of interop between Clojure and JavaScript in a Clojure function <code>now</code>. Now if we want to get the current time string from the <code>luxon</code> library, we can just call the <code>now</code> function. The interop is still something quite cumbersome to do, however. In this blog I will show you how to turn it into something way more concise using the macros and other facilities provided by Clojure. Here is a glimpse of it:
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-name">js..</span> lux/DateTime now toString) <span class="hljs-comment">;; &quot;2025-11-15T17:04:38.574+08:00&quot;</span>
</body></html></code></pre>
</div>
</div>
</div>
<div id="outline-container-ease-things-with-helper-functions,-macros-and-more" class="outline-2">
<a href="#ease-things-with-helper-functions,-macros-and-more"><h2 id="ease-things-with-helper-functions,-macros-and-more" class="cr-self-reference ">Ease Things With Helper Functions, Macros and More</h2></a>
<div class="outline-text-2" id="text-ease-things-with-helper-functions,-macros-and-more">
<p>
You must have noticed the definition of the <code>now</code> function in the previous example is quite clumsy. In ClojureScript we have the following things that can facilitate the interop between ClojureScript and JavaScript
</p>
<ul class="org-ul">
<li>We can require a js module just like a clojure namespace</li>
<li>A ClojureScript function is just a JavaScript function, we can call JavaScript functions from the ClojureScript side, or we can pass ClojureScript functions to the JavaScript side.</li>
<li>We have dot macros ( <code>.</code>, <code>..</code> and <code>.-</code> ) and <code>set!</code> to easily access properites or methods of JavaScript objects.</li>
</ul>

<p>
To build something on the same level is probably very hard, however, to build a demonstration of something very similar is indeed very achievable.
</p>
</div>
<div id="outline-container-mapping-between-clojure-and-polyglot-values" class="outline-3">
<a href="#mapping-between-clojure-and-polyglot-values"><h3 id="mapping-between-clojure-and-polyglot-values" class="cr-self-reference ">Mapping between Clojure and Polyglot Values</h3></a>
<div class="outline-text-3" id="text-mapping-between-clojure-and-polyglot-values">
<p>
We probably don't want to manually convert the result each time we get a value from the JavaScript side as we did in the previous examples. So we would like to put the actual JavaScript functions invoking logics into a wrapper and let the wrapper automatically convert the parameters and the return value for us. To make something like this, and since GraalJS represents each JavaScript value as a Polyglot Value, we first need to establish a mapping between Clojure types and Polyglot Types.
</p>
</div>
<div id="outline-container-primitive-types" class="outline-4">
<a href="#primitive-types"><h4 id="primitive-types" class="cr-self-reference ">Primitive Types</h4></a>
<div class="outline-text-4" id="text-primitive-types">
<p>
Each time we call the <code>.execute()</code> or <code>.invokeMember()</code> method of the <code>polyglot.Value</code> class, GraalJS will convert the arguments using <code>.asValue()</code> method of <code>Context</code> class. However, we are going to wrap Clojure functions as Polyglot functions in the next section. As of now, we write a Clojure -&gt; Polyglot mapping function only calling the <code>.asValue()</code> method.
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-keyword">defn</span> <span class="hljs-title">polyglotalize-clojure</span> [value]
  (<span class="hljs-name"><span class="hljs-built_in">cond</span></span>
    <span class="hljs-comment">;; https://www.graalvm.org/sdk/javadoc/org/graalvm/polyglot/Context.html#asValue(java.lang.Object)</span>
    <span class="hljs-symbol">:else</span>
    (<span class="hljs-name">.asValue</span> *context* value)))
</body></html></code></pre>
</div>

<p>
As for the mapping from <code>polyglot.Value</code> to Clojure values, we use the various checking and converting methods described before.
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-keyword">defn</span> <span class="hljs-title">clojurify-value</span> [^org.graalvm.polyglot.Value value]
  (<span class="hljs-name"><span class="hljs-built_in">cond</span></span> (<span class="hljs-name">.isHostObject</span> value)
        (<span class="hljs-name">.asHostObject</span> value)

        (<span class="hljs-name">.isBoolean</span> value)
        (<span class="hljs-name">.asBoolean</span> value)

        (<span class="hljs-name">.isNull</span> value)
        <span class="hljs-literal">nil</span>

        (<span class="hljs-name">.isString</span> value)
        (<span class="hljs-name">.asString</span> value)

        (<span class="hljs-name">.isNumber</span> value)
        (<span class="hljs-name"><span class="hljs-built_in">cond</span></span> (<span class="hljs-name">.fitsInLong</span> value)
              (<span class="hljs-name">.asLong</span> value)

              (<span class="hljs-name">.fitsInDouble</span> value)
              (<span class="hljs-name">.asDouble</span> value))

        <span class="hljs-symbol">:else</span>
        value))
</body></html></code></pre>
</div>
</div>
</div>
<div id="outline-container-functions" class="outline-4">
<a href="#functions"><h4 id="functions" class="cr-self-reference ">Functions</h4></a>
<div class="outline-text-4" id="text-functions">
<p>
GraalVM provides various <code>Proxy</code> objects that we can use to make Clojure objects accessible in the JavaScript environment. To wrap a function, we need to use <code>ProxyExecutable</code>.
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-keyword">defn</span> <span class="hljs-title">wrap-clojure-fn</span> [f]
  (<span class="hljs-name">.asValue</span> *context*
            (<span class="hljs-name"><span class="hljs-built_in">with-meta</span></span> (<span class="hljs-name"><span class="hljs-built_in">reify</span></span> org.graalvm.polyglot.proxy.ProxyExecutable
                         #_{<span class="hljs-symbol">:clj-kondo/ignore</span> [<span class="hljs-symbol">:unused-binding</span>]}
                         <span class="hljs-comment">;; we ignore `this` for now</span>
                         (<span class="hljs-name">execute</span> [this ^<span class="hljs-string">&quot;[Lorg.graalvm.polyglot.Value;&quot;</span> values]
                           (<span class="hljs-name">polyglotalize-clojure</span> (<span class="hljs-name"><span class="hljs-built_in">apply</span></span> f (<span class="hljs-name"><span class="hljs-built_in">map</span></span> clojurify-value values)))))
              {<span class="hljs-symbol">::raw-fn</span> f})))
</body></html></code></pre>
</div>

<p>
The function takes a Clojure function as an argument, returns a Polyglot executable that we can pass to the JavaScript environment.
</p>

<p>
In the function body, we use <code>reify</code> to instantiate an object implementing the <code>ProxyExecutable</code> interface. We implement the <code>.execute()</code> method by applying the clojurified arguments to the original Clojure function, and convert the return value back to a Polyglot value using the two functions we wrote in the <a href="#primitive-types">previous section</a>.
</p>

<p>
In case we want to turn the proxy object back into a clojure function (like when a JavaScript function returns the proxy object as is), we save the original Clojure function into the <a href="https://clojure.org/reference/metadata">metadata</a> of the proxy object using <code>with-meta</code>. In the final step, we turn it into a Polyglot Value using <code>.asValue</code> method from <code>Context</code>.
</p>

<p>
Wrapping functions from JavaScript follows a similar logic.
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-keyword">defn</span> <span class="hljs-title">wrap-polyglot-executable</span> [^org.graalvm.polyglot.Value obj]
  (<span class="hljs-name"><span class="hljs-built_in">with-meta</span></span> (<span class="hljs-name"><span class="hljs-built_in">fn</span></span> [&amp; args]
               (<span class="hljs-name">clojurify-value</span> (<span class="hljs-name">.execute</span> obj (<span class="hljs-name"><span class="hljs-built_in">into-array</span></span> Object (<span class="hljs-name"><span class="hljs-built_in">map</span></span> polyglotalize-clojure args)))))
    {<span class="hljs-symbol">::raw-value</span> obj}))
</body></html></code></pre>
</div>

<p>
Here, we also save a reference to the original JavaScript function in the metadata. However, it serves a much more important role: In JavaScript, a function is like any object, it can have all kinds of properties. Therefore, after wrapping a JavaScript function as a Clojure function, we may still need to access its other properties. To do this, we save the original function in the metadata and retrieve it if necessary.
</p>

<p>
With these two functions defined, we can then augmented our two mapping functions.
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-keyword">defn</span> <span class="hljs-title">polyglotalize-clojure</span> [value]
  (<span class="hljs-name"><span class="hljs-built_in">cond</span></span> (<span class="hljs-symbol">::raw-value</span> (<span class="hljs-name"><span class="hljs-built_in">meta</span></span> value))
        (<span class="hljs-symbol">::raw-value</span> (<span class="hljs-name"><span class="hljs-built_in">meta</span></span> value))

        (<span class="hljs-name"><span class="hljs-built_in">fn?</span></span> value)
        (<span class="hljs-name">wrap-clojure-fn</span> value)

        <span class="hljs-symbol">:else</span>
        <span class="hljs-comment">;; https://www.graalvm.org/sdk/javadoc/org/graalvm/polyglot/Context.html#asValue(java.lang.Object)</span>
        (<span class="hljs-name">.asValue</span> *context* value)))
</body></html></code></pre>
</div>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-keyword">defn</span> <span class="hljs-title">clojurify-value</span> [^org.graalvm.polyglot.Value value]
  (<span class="hljs-name"><span class="hljs-built_in">cond</span></span>

    (<span class="hljs-name">.isProxyObject</span> value)
    (<span class="hljs-name"><span class="hljs-built_in">let</span></span> [prox-obj (<span class="hljs-name">.asProxyObject</span> value)]
      (<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-symbol">::raw-fn</span> (<span class="hljs-name"><span class="hljs-built_in">meta</span></span> prox-obj))
        (<span class="hljs-symbol">::raw-fn</span> (<span class="hljs-name"><span class="hljs-built_in">meta</span></span> prox-obj))
        prox-obj))

    <span class="hljs-comment">;;</span>
    <span class="hljs-comment">;; ... omitted</span>
    <span class="hljs-comment">;;</span>

    (<span class="hljs-name">.canExecute</span> value) 
    (<span class="hljs-name">wrap-polyglot-executable</span> value)

    <span class="hljs-symbol">:else</span>
    value))
</body></html></code></pre>
</div>

<p>
With these two facilities created, we already achieve something very interesting.
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-keyword">def</span> <span class="hljs-title">hello</span> (<span class="hljs-name">clojurify-value</span> (<span class="hljs-name">.eval</span> *context* <span class="hljs-string">&quot;js&quot;</span> <span class="hljs-string">&quot;(function (name){console.log(`hello ${name}`)})&quot;</span>)))

(<span class="hljs-name">hello</span> <span class="hljs-string">&quot;world&quot;</span>) <span class="hljs-comment">;; output: hello world</span>
(<span class="hljs-name">hello</span> <span class="hljs-string">&quot;graaljs&quot;</span>) <span class="hljs-comment">;; output: hello graaljs</span>

(<span class="hljs-keyword">def</span> <span class="hljs-title">to-array</span> (<span class="hljs-name">clojurify-value</span>
               (<span class="hljs-name">.eval</span> *context* <span class="hljs-string">&quot;js&quot;</span> <span class="hljs-string">&quot;(function (...args){return Array.from(args);})&quot;</span>)))

(<span class="hljs-name"><span class="hljs-built_in">to-array</span></span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>) <span class="hljs-comment">;; #object[org.graalvm.polyglot.Value 0x26e3da6b &quot;(4)[1, 2, 3, 4]&quot;]</span>

(<span class="hljs-keyword">def</span> <span class="hljs-title">join</span> (<span class="hljs-name">clojurify-value</span>
           (<span class="hljs-name">.eval</span> *context* <span class="hljs-string">&quot;js&quot;</span> <span class="hljs-string">&quot;(function (s, ...args){return args.join(s);})&quot;</span>)))

(<span class="hljs-name">join</span> <span class="hljs-string">&quot;,&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>) <span class="hljs-comment">;; &quot;1,2,3,4&quot;</span>
</body></html></code></pre>
</div>

<p>
As you have seen, we can now call a JavaScript function just like a Clojure function. Return values of primitive types will also be automatically converted back to Clojure values.
</p>

<p>
We can also pass Clojure functions to the JavaScript side:
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-keyword">def</span> <span class="hljs-title">sum-term</span>
  (<span class="hljs-name">clojurify-value</span>
   (<span class="hljs-name">.eval</span> *context* <span class="hljs-string">&quot;js&quot;</span> <span class="hljs-string">&quot;let sum = (term, a, b) =&gt; (a&gt;b)? 0 : term(a) + sum(term, a+1,b); sum&quot;</span>)))

<span class="hljs-comment">;; (sum-integers a b) calculate the sum of integers from `a` to `b` (inclusive)</span>
(<span class="hljs-keyword">def</span> <span class="hljs-title">sum-integers</span> (<span class="hljs-name"><span class="hljs-built_in">partial</span></span> sum-term identity))
(<span class="hljs-name">sum-integers</span> <span class="hljs-number">0</span> <span class="hljs-number">10</span>) <span class="hljs-comment">;; 55</span>

<span class="hljs-comment">;; (sum-cubes a b) calculates the sum of cubes of integers from `a` to `b` (inclusive)</span>
(<span class="hljs-keyword">def</span> <span class="hljs-title">sum-cubes</span> (<span class="hljs-name"><span class="hljs-built_in">partial</span></span> sum-term (<span class="hljs-name"><span class="hljs-built_in">fn</span></span> [x] (<span class="hljs-name"><span class="hljs-built_in">*</span></span> x x x))))
(<span class="hljs-name">sum-cubes</span> <span class="hljs-number">0</span> <span class="hljs-number">10</span>) <span class="hljs-comment">;; 3025</span>
</body></html></code></pre>
</div>
</div>
</div>
<div id="outline-container-mapping_objects" class="outline-4">
<a href="#mapping_objects"><h4 id="mapping_objects" class="cr-self-reference ">Objects</h4></a>
<div class="outline-text-4" id="text-mapping_objects">
<p>
Rougly similar to ClojureScript, We don't do mapping for objects other than those of primitives types and functions. However, in the <code>clojurify-value</code> function, we wrap all JavaScript functions into Clojure functions and save the reference in the metadata, and as I have explained there, a JavaScript function may have other properties we want to access. Thus, in each place where a Clojure function wrapping a JavaScript function can be taken as arguments, we cannot use methods from <code>polyglot.Value</code>. Instead, we define helper functions that will wrap the arguments if necessary and then call the target method.
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-keyword">defn</span> <span class="hljs-title">polyglot-value</span> [obj]
  (<span class="hljs-name"><span class="hljs-built_in">or</span></span> (<span class="hljs-symbol">::raw-value</span> (<span class="hljs-name"><span class="hljs-built_in">meta</span></span> obj))
      (<span class="hljs-name"><span class="hljs-built_in">and</span></span> (<span class="hljs-name"><span class="hljs-built_in">instance?</span></span> org.graalvm.polyglot.Value obj)
           obj)))

(<span class="hljs-keyword">defn-</span> <span class="hljs-title">to-camel-style</span> [s]
  (<span class="hljs-name">string/replace</span> s <span class="hljs-regex">#&quot;-([a-z])&quot;</span> (<span class="hljs-name"><span class="hljs-built_in">fn</span></span> [g]
                                  (<span class="hljs-name">.toUpperCase</span> (<span class="hljs-name"><span class="hljs-built_in">second</span></span> g)))))

(<span class="hljs-keyword">defmacro</span> <span class="hljs-title">define-unwrap-executable-alias</span>
  {<span class="hljs-symbol">:clj-kondo/lint-as</span> 'clojure.core/declare}
  [name &amp; args]
  (<span class="hljs-name"><span class="hljs-built_in">let</span></span> [docstring? (<span class="hljs-name"><span class="hljs-built_in">string?</span></span> (<span class="hljs-name"><span class="hljs-built_in">first</span></span> args))
        docstring (<span class="hljs-name"><span class="hljs-built_in">when</span></span> docstring? (<span class="hljs-name"><span class="hljs-built_in">first</span></span> args))
        args (<span class="hljs-name"><span class="hljs-built_in">if</span></span> docstring? (<span class="hljs-name"><span class="hljs-built_in">second</span></span> args) (<span class="hljs-name"><span class="hljs-built_in">first</span></span> args))
        obj 'obj
        [arglist [_ vararg]] (<span class="hljs-name"><span class="hljs-built_in">split-with</span></span> (<span class="hljs-name"><span class="hljs-built_in">fn</span></span> [x] (<span class="hljs-name"><span class="hljs-built_in">not</span></span> (<span class="hljs-name"><span class="hljs-built_in">=</span></span> x '&amp;))) args)] 
    `(<span class="hljs-keyword">defn</span> ~<span class="hljs-title">name</span> {<span class="hljs-symbol">:doc</span> ~docstring} [~obj ~@arglist ~@(<span class="hljs-name"><span class="hljs-built_in">if</span></span> vararg `[&amp; ~vararg] [])]
       (<span class="hljs-name"><span class="hljs-built_in">let</span></span> [~obj (<span class="hljs-name"><span class="hljs-built_in">or</span></span> (<span class="hljs-name">polyglot-value</span> ~obj)
                      ~obj)]
         (~(<span class="hljs-name"><span class="hljs-built_in">symbol</span></span> (<span class="hljs-name"><span class="hljs-built_in">str</span></span> <span class="hljs-string">&quot;.&quot;</span> (<span class="hljs-name">to-camel-style</span> (<span class="hljs-name"><span class="hljs-built_in">str</span></span> name))))
          ~obj 
          ~@arglist
          ~@(<span class="hljs-name"><span class="hljs-built_in">if</span></span> vararg
              [`(<span class="hljs-name"><span class="hljs-built_in">into-array</span></span> Object ~vararg)]
              []))))))

(<span class="hljs-name">define-unwrap-executable-alias</span> get-meta-object)
(<span class="hljs-name">define-unwrap-executable-alias</span> is-meta-object)
(<span class="hljs-name">define-unwrap-executable-alias</span> get-meta-qualified-name)
(<span class="hljs-name">define-unwrap-executable-alias</span> has-meta-parents)
(<span class="hljs-name">define-unwrap-executable-alias</span> has-array-elements)
(<span class="hljs-name">define-unwrap-executable-alias</span> get-meta-parents)
(<span class="hljs-name">define-unwrap-executable-alias</span> get-member [^String identifier])
(<span class="hljs-name">define-unwrap-executable-alias</span> put-member [^String identifier ^Object value])
(<span class="hljs-name">define-unwrap-executable-alias</span> get-member-keys)
(<span class="hljs-name">define-unwrap-executable-alias</span> new-instance [&amp; args])
(<span class="hljs-name">define-unwrap-executable-alias</span> can-invoke-member [^String s])
(<span class="hljs-name">define-unwrap-executable-alias</span> invoke-member [^String method &amp; args])
(<span class="hljs-name">define-unwrap-executable-alias</span> can-instantiate)
(<span class="hljs-name">define-unwrap-executable-alias</span> canExecute)
(<span class="hljs-name">define-unwrap-executable-alias</span> execute [&amp; args])
(<span class="hljs-name">define-unwrap-executable-alias</span> executeVoid [&amp; args])
</body></html></code></pre>
</div>

<p>
We wrote a macro for this purpose. The macro takes a function name and a parameter list as arguments and defines a function with the name and parameters.
The function defined by the macro retrieves the reference from the metadata if necessary, then calls a method by the name converted from the function name and with arguments from the parameter list.
</p>

<p>
One nice bonus is that the generated functions assembles all the variadic arguments into an <code>Object[]</code>, saving us from calling <code>(into-arry Object)</code> manually if we need to call a method with variadic arguments.
</p>

<p>
Previously we need to do this:
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-name">.newInstance</span> (<span class="hljs-name">.eval</span> *context* <span class="hljs-string">&quot;js&quot;</span> <span class="hljs-string">&quot;Array&quot;</span>) (<span class="hljs-name"><span class="hljs-built_in">into-array</span></span> Object [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]))
<span class="hljs-comment">;; #object[org.graalvm.polyglot.Value 0x65b337ef &quot;(3)[1, 2, 3]&quot;]</span>
</body></html></code></pre>
</div>

<p>
Now we just need to do this:
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-name">new-instance</span> (<span class="hljs-name">.eval</span> *context* <span class="hljs-string">&quot;js&quot;</span> <span class="hljs-string">&quot;Array&quot;</span>) <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)
<span class="hljs-comment">;; #object[org.graalvm.polyglot.Value 0xfdabe76 &quot;(3)[1, 2, 3]&quot;]</span>
</body></html></code></pre>
</div>
</div>
</div>
</div>
<div id="outline-container-dot-macros-and-~set!~" class="outline-3">
<a href="#dot-macros-and-~set!~"><h3 id="dot-macros-and-~set!~" class="cr-self-reference ">Dot Macros and <code>set!</code></h3></a>
<div class="outline-text-3" id="text-dot-macros-and-~set!~">
<p>
In ClojureScript we have dots special forms or macros like <code>.</code>,  <code>.-</code> and <code>..</code> for accessing properties or calling methods of JavaScript objects.
</p>

<p>
We can relatively easily implement them using macros.
</p>

<blockquote>
<p>
There are also <code>(.method obj)</code> <code>(.-property obj)</code> as shorthands for <code>(. obj method)</code> and <code>(.- obj property)</code> in ClojureScript. However, implementing them would be really difficult if not impossible.
</p>
</blockquote>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-keyword">defmacro</span> <span class="hljs-title">js.</span>
  {<span class="hljs-symbol">:clj-kondo/ignore</span> [<span class="hljs-symbol">:unresolved-symbol</span> <span class="hljs-symbol">:type-mismatch</span>]}
  [obj method &amp; args]
  `(<span class="hljs-name">clojurify-value</span>
    (<span class="hljs-name"><span class="hljs-built_in">apply</span></span> invoke-member ~obj ~(<span class="hljs-name"><span class="hljs-built_in">str</span></span> method)
           <span class="hljs-comment">;; evaluate args before passing them to polyglotalize-clojure</span>
           (<span class="hljs-name"><span class="hljs-built_in">map</span></span> polyglotalize-clojure (<span class="hljs-name"><span class="hljs-built_in">list</span></span> ~@args)))))


(<span class="hljs-keyword">defmacro</span> <span class="hljs-title">js.-</span>
  {<span class="hljs-symbol">:clj-kondo/ignore</span> [<span class="hljs-symbol">:unresolved-symbol</span> <span class="hljs-symbol">:type-mismatch</span>]}
  [obj field]
  `(<span class="hljs-name">#'clojurify-value</span> (<span class="hljs-name">get-member</span> ~obj ~(<span class="hljs-name"><span class="hljs-built_in">str</span></span> field))))
</body></html></code></pre>
</div>

<p>
The <code>invoke-member</code> and <code>get-member</code> helper functions are defined in the <a href="#mapping_objects">previous section</a>.
</p>

<p>
With these two defined, we can write the more complicated macro <code>js..</code> based on them.
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-keyword">defmacro</span> <span class="hljs-title">js..</span>
  {<span class="hljs-symbol">:clj-kondo/ignore</span> [<span class="hljs-symbol">:unresolved-symbol</span> <span class="hljs-symbol">:type-mismatch</span>]}
  [obj &amp; args]
  (<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name"><span class="hljs-built_in">empty?</span></span> args)
    obj
    (<span class="hljs-name"><span class="hljs-built_in">let</span></span> [curr# (<span class="hljs-name"><span class="hljs-built_in">first</span></span> args)
          rest# (<span class="hljs-name"><span class="hljs-built_in">rest</span></span> args)]
      `(<span class="hljs-name">js..</span> ~(<span class="hljs-name"><span class="hljs-built_in">cond</span></span> (<span class="hljs-name"><span class="hljs-built_in">seq?</span></span> curr#)
                    `(<span class="hljs-name">js.</span> ~obj ~(<span class="hljs-name"><span class="hljs-built_in">first</span></span> curr#) ~@(<span class="hljs-name"><span class="hljs-built_in">rest</span></span> curr#))

                    (<span class="hljs-name">.startsWith</span> (<span class="hljs-name"><span class="hljs-built_in">str</span></span> curr#)
                                 <span class="hljs-string">&quot;-&quot;</span>)
                    `(<span class="hljs-name">js.-</span> ~obj ~(<span class="hljs-name">subs</span> (<span class="hljs-name"><span class="hljs-built_in">str</span></span> curr#) <span class="hljs-number">1</span>))

                    <span class="hljs-symbol">:else</span>
                    `(<span class="hljs-name">js.</span> ~obj ~curr#))
         ~@rest#))))
</body></html></code></pre>
</div>

<p>
Finally, we will implement the <code>set!</code> macro.
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-keyword">defmacro</span> <span class="hljs-title">js-set!</span> [dot-form value]
  (<span class="hljs-name"><span class="hljs-built_in">assert</span></span> (<span class="hljs-name"><span class="hljs-built_in">seq?</span></span> dot-form) <span class="hljs-string">&quot;First argument must be in the form of `(js.. obj -field)` or (js.- obj field)&quot;</span>)
  (<span class="hljs-name"><span class="hljs-built_in">let</span></span> [[op &amp; args] dot-form]
    (<span class="hljs-name"><span class="hljs-built_in">assert</span></span> (<span class="hljs-name"><span class="hljs-built_in">or</span></span> (<span class="hljs-name"><span class="hljs-built_in">=</span></span> op 'js..)
                (<span class="hljs-name"><span class="hljs-built_in">=</span></span> op 'js.-))
            <span class="hljs-string">&quot;First argument to js-set! must start with either `js..` or `js.-`&quot;</span>)
    (<span class="hljs-name"><span class="hljs-built_in">let</span></span> [remove-hyphen (<span class="hljs-name"><span class="hljs-built_in">=</span></span> op 'js..)
          lst (<span class="hljs-name"><span class="hljs-built_in">last</span></span> args)
          last-removed (<span class="hljs-name"><span class="hljs-built_in">drop-last</span></span> (<span class="hljs-name"><span class="hljs-built_in">into</span></span> [op] args))]
      `(<span class="hljs-name">put-member</span> ~(<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name"><span class="hljs-built_in">=</span></span> (<span class="hljs-name"><span class="hljs-built_in">count</span></span> last-removed) <span class="hljs-number">2</span>)
                      (<span class="hljs-name"><span class="hljs-built_in">second</span></span> last-removed)
                      last-removed)
                   ~(<span class="hljs-name"><span class="hljs-built_in">if</span></span> remove-hyphen
                      (<span class="hljs-name">subs</span> (<span class="hljs-name"><span class="hljs-built_in">str</span></span> lst) <span class="hljs-number">1</span>)
                      (<span class="hljs-name"><span class="hljs-built_in">str</span></span> lst))
                   ~value))))
</body></html></code></pre>
</div>

<p>
Let's go back to the <code>luxon</code> example mentioned in the beginning of this blog and check what we can do with these newly defined tools.
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-keyword">def</span> <span class="hljs-title">luxon</span> (<span class="hljs-name">.eval</span> *context* <span class="hljs-string">&quot;js&quot;</span> <span class="hljs-string">&quot;require('luxon')&quot;</span>))

(<span class="hljs-name">js..</span> luxon -DateTime now toString) <span class="hljs-comment">;; &quot;2025-11-14T16:48:11.324+08:00&quot;</span>
</body></html></code></pre>
</div>

<p>
Compare it to the snippet I showed at the end of the first section:
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-name">js..</span> lux/DateTime now toString)
</body></html></code></pre>
</div>

<p>
The only thing lacking is a <code>require</code> mechanism, which is what we are going to implement in the next section.
</p>
</div>
</div>
<div id="outline-container-~require~-command" class="outline-3">
<a href="#~require~-command"><h3 id="~require~-command" class="cr-self-reference "><code>require</code> command</h3></a>
<div class="outline-text-3" id="text-~require~-command">
<p>
On the JavaScript side, the <code>require()</code> function returns an object from which we can access its exported variables or functions.
</p>

<p>
On the Clojure side, we can dynamically create a namespace with the <code>create-ns</code> function. After that we can make all the variables from the module object accessible in the newly created namespace with the <code>intern</code> function.
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-keyword">defn-</span> <span class="hljs-title">require-module</span> [name]
  (<span class="hljs-name"><span class="hljs-built_in">-&gt;</span></span> *context*
      (<span class="hljs-name">.eval</span> <span class="hljs-string">&quot;js&quot;</span>
             (<span class="hljs-name"><span class="hljs-built_in">str</span></span> <span class="hljs-string">&quot;require('&quot;</span> name <span class="hljs-string">&quot;')&quot;</span>))))

(<span class="hljs-keyword">defn-</span> <span class="hljs-title">parse-flags</span> [args]
  (<span class="hljs-name"><span class="hljs-built_in">loop</span></span> [args (<span class="hljs-name"><span class="hljs-built_in">lazy-seq</span></span> args)
         result (<span class="hljs-name"><span class="hljs-built_in">hash-map</span></span>)]
    (<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name"><span class="hljs-built_in">empty?</span></span> args)
      result
      (<span class="hljs-name"><span class="hljs-built_in">let</span></span> [curr (<span class="hljs-name"><span class="hljs-built_in">first</span></span> args)
            rst (<span class="hljs-name"><span class="hljs-built_in">rest</span></span> args)]
        (<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name"><span class="hljs-built_in">or</span></span> (<span class="hljs-name"><span class="hljs-built_in">keyword?</span></span> (<span class="hljs-name"><span class="hljs-built_in">first</span></span> rst))
                (<span class="hljs-name"><span class="hljs-built_in">empty?</span></span> rst))
          (<span class="hljs-name"><span class="hljs-built_in">recur</span></span> rst (<span class="hljs-name"><span class="hljs-built_in">assoc</span></span> result curr <span class="hljs-literal">true</span>))
          (<span class="hljs-name"><span class="hljs-built_in">recur</span></span> (<span class="hljs-name"><span class="hljs-built_in">rest</span></span> rst)
                 (<span class="hljs-name"><span class="hljs-built_in">assoc</span></span> result curr (<span class="hljs-name"><span class="hljs-built_in">first</span></span> rst))))))))

(<span class="hljs-keyword">defn-</span> <span class="hljs-title">normalize-module-name</span> [name]
  (<span class="hljs-name">s/replace</span> (<span class="hljs-name"><span class="hljs-built_in">str</span></span> name) <span class="hljs-regex">#&quot;/&quot;</span> <span class="hljs-string">&quot;.&quot;</span>))

(<span class="hljs-keyword">defn</span> <span class="hljs-title">require-js</span>
  {<span class="hljs-symbol">:clj-kondo/lint-as</span> 'clojure.core/require}
  [[module-name &amp; flags] &amp; coll]
  (<span class="hljs-name"><span class="hljs-built_in">let</span></span> [flag-map (<span class="hljs-name">parse-flags</span> flags)
        module (<span class="hljs-name">require-module</span> module-name)
        alias-name (<span class="hljs-symbol">:as</span> flag-map)
        qualified-module-name (<span class="hljs-name"><span class="hljs-built_in">symbol</span></span> (<span class="hljs-name"><span class="hljs-built_in">str</span></span> <span class="hljs-string">&quot;js4clj.modules.&quot;</span> (<span class="hljs-name">normalize-module-name</span> module-name)))]
    (<span class="hljs-name"><span class="hljs-built_in">create-ns</span></span> qualified-module-name)
    (<span class="hljs-name"><span class="hljs-built_in">doseq</span></span> [k (<span class="hljs-name">.getMemberKeys</span> module)]
      (<span class="hljs-name"><span class="hljs-built_in">intern</span></span> qualified-module-name
              (<span class="hljs-name"><span class="hljs-built_in">symbol</span></span> k)
              (<span class="hljs-name">clojurify-value</span> (<span class="hljs-name">.getMember</span> module k))))
    (<span class="hljs-name"><span class="hljs-built_in">when</span></span> alias-name
      (<span class="hljs-name"><span class="hljs-built_in">alias</span></span> alias-name qualified-module-name)))
  (<span class="hljs-name"><span class="hljs-built_in">when</span></span> (<span class="hljs-name"><span class="hljs-built_in">seq</span></span> coll)
    (<span class="hljs-name"><span class="hljs-built_in">apply</span></span> require-js coll)))
</body></html></code></pre>
</div>

<p>
<code>(require-js '[luxon :as lux])</code> is now all we need to require a JavaScript module.
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-name">require-js</span> '[luxon <span class="hljs-symbol">:as</span> lux])

(<span class="hljs-name">js..</span> lux/DateTime now toString) <span class="hljs-comment">;; &quot;2025-11-14T17:08:40.045+08:00&quot;</span>
</body></html></code></pre>
</div>

<p>
Let's try some more examples:
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-name">js..</span> lux/DateTime (<span class="hljs-name">fromISO</span> <span class="hljs-string">&quot;2017-05-15T08:30:00&quot;</span>) -year) <span class="hljs-comment">;; 2017</span>

<span class="hljs-comment">;; or write it as</span>
(<span class="hljs-name"><span class="hljs-built_in">-&gt;</span></span> lux/DateTime
    (<span class="hljs-name">js.</span> fromISO <span class="hljs-string">&quot;2017-05-15T08:30:00&quot;</span>)
    (<span class="hljs-name">js.-</span> year)) <span class="hljs-comment">;; 2017</span>

(<span class="hljs-name"><span class="hljs-built_in">let</span></span> [now (<span class="hljs-name">js.</span> lux/DateTime now)
      later (<span class="hljs-name">js.</span> lux/DateTime local <span class="hljs-number">2026</span> <span class="hljs-number">10</span> <span class="hljs-number">12</span>)
      i (<span class="hljs-name">js.</span> lux/Interval fromDateTimes now later)]
  (<span class="hljs-name">js.</span> i length <span class="hljs-string">&quot;years&quot;</span>)) <span class="hljs-comment">;; 0.904136850298072</span>
</body></html></code></pre>
</div>
</div>
</div>
<div id="outline-container-bonus:-special-~js~-namespace" class="outline-3">
<a href="#bonus:-special-~js~-namespace"><h3 id="bonus:-special-~js~-namespace" class="cr-self-reference ">Bonus: Special <code>js</code> namespace</h3></a>
<div class="outline-text-3" id="text-bonus:-special-~js~-namespace">
<p>
ClojureScript provides us a <a href="https://cljs.github.io/api/syntax/js-namespace">special <code>js</code> namespace</a>, from where we can use various JavaScript global objects. We can also implement something like that.
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body>(<span class="hljs-keyword">def</span> ^<span class="hljs-symbol">:dynamic</span> <span class="hljs-title">*no-clojurify*</span> <span class="hljs-literal">false</span>)

(<span class="hljs-keyword">defn-</span> <span class="hljs-title">define-builtin</span> [ns primitive &amp; [alias]]
  (<span class="hljs-name"><span class="hljs-built_in">intern</span></span> ns (<span class="hljs-name"><span class="hljs-built_in">if</span></span> alias (<span class="hljs-name"><span class="hljs-built_in">symbol</span></span> alias) (<span class="hljs-name"><span class="hljs-built_in">symbol</span></span> primitive))
          ((<span class="hljs-name"><span class="hljs-built_in">if</span></span> *no-clojurify* identity clojurify-value)
           (<span class="hljs-name">.eval</span> *context* <span class="hljs-string">&quot;js&quot;</span> primitive))))

(<span class="hljs-keyword">defmacro</span> <span class="hljs-title">define-builtins</span>
  {<span class="hljs-symbol">:clj-kondo/lint-as</span> 'clojure.core/declare}
  [ns &amp; primitives]
  (<span class="hljs-name"><span class="hljs-built_in">create-ns</span></span> ns)
  `(<span class="hljs-name"><span class="hljs-built_in">doseq</span></span> [primitive# '~primitives]
     (<span class="hljs-name">define-builtin</span> '~ns (<span class="hljs-name"><span class="hljs-built_in">str</span></span> primitive#))))

<span class="hljs-comment">;; In cljs there is also a js/undefined</span>
<span class="hljs-comment">;;	in which (= nil js/undefined) but we can't mimic it.</span>
<span class="hljs-comment">;; Still, we need a js/undefined in case we need to do some</span>
<span class="hljs-comment">;; 	very specific interop.</span>
(<span class="hljs-name"><span class="hljs-built_in">declare</span></span> undefined)
(<span class="hljs-name">with-bindings</span> {#'*no-clojurify* <span class="hljs-literal">true</span>}
  (<span class="hljs-name">define-builtin</span> 'js <span class="hljs-string">&quot;undefined&quot;</span> <span class="hljs-string">&quot;undefined&quot;</span>))

#_{<span class="hljs-symbol">:clojure-lsp/ignore</span> [<span class="hljs-symbol">:clojure-lsp/unused-public-var</span>]}
(<span class="hljs-name">define-builtins</span> js
  globalThis
  Infinity
  NaN
  Object
  Function
  Boolean
  Symbol
  Error
  Number
  BigInt
  Math
  Date
  String
  Array
  Map
  Set
  WeakMap
  WeakSet
  JSON
  ArrayBuffer
  Promise
  console)
</body></html></code></pre>
</div>

<p>
We took a special handling of <code>js/undefined</code> (note when we clojurify JavaScript values, we turn both <code>null</code> and <code>undefined</code> into <code>nil</code>), since a direct equivalent of <code>undefined</code> in JavaScript may be needed for some interops. However, <code>js/undefined</code> In ClojureScript has some special properties we can't replicate, most notably, <code>(nil? js/undefined)</code> and <code>(= js/undefined nil)</code> results in <code>true</code> in ClojureScript.
</p>
</div>
</div>
</div>
<div id="outline-container-limitations" class="outline-2">
<a href="#limitations"><h2 id="limitations" class="cr-self-reference ">Limitations</h2></a>
<div class="outline-text-2" id="text-limitations">
</div>
<div id="outline-container-functionalities-specific-to-an-environment" class="outline-3">
<a href="#functionalities-specific-to-an-environment"><h3 id="functionalities-specific-to-an-environment" class="cr-self-reference ">Functionalities specific to an environment</h3></a>
<div class="outline-text-3" id="text-functionalities-specific-to-an-environment">
<p>
JavaScript packages are often written under the assumption that, the code will either run on a Browser or a node.js environment. Unfortunately, GraalJS only implements the ECMAScript specification, which means we have neither functions specific to node.js nor functions specific to a browser.
</p>

<p>
For example, we don't have <code>WebWorker</code> api from the browser, nor <code>process</code>, <code>fs</code> api from node.js.
</p>
</div>
</div>
<div id="outline-container-multithreading-and-the-~js~-namespace" class="outline-3">
<a href="#multithreading-and-the-~js~-namespace"><h3 id="multithreading-and-the-~js~-namespace" class="cr-self-reference ">Multithreading and the <code>js</code> namespace</h3></a>
<div class="outline-text-3" id="text-multithreading-and-the-~js~-namespace">
<p>
When writing programs in Java, we usually use blocking operations and multithreading. However, <code>polyglot.Context</code> is not thread-safe. It isn't a problem in itself, since we can spin up multiple contexts. However, variables in <code>js</code> refer to variables in a specific context. Thus, if we want to use multiple contexts, we cannot refer to variables in the <code>js</code> namespace with the current settings. We may be able to mitigate or solve this problem with dynamic bindings or using a dedicated thread for JavaScript operations.
</p>
</div>
</div>
<div id="outline-container-shorthands-for-dot-macros" class="outline-3">
<a href="#shorthands-for-dot-macros"><h3 id="shorthands-for-dot-macros" class="cr-self-reference ">Shorthands for dot macros</h3></a>
<div class="outline-text-3" id="text-shorthands-for-dot-macros">
<p>
We have already talked about it in the <a href="#dot-macros-and-~set!~">Dot Macros</a> section. In ClojureScript we can <code>(ClassName.)</code> for instantiate an instance or <code>(.method obj)</code> for invoking an method. Implementing them would be really hard if not impossible.
</p>
</div>
</div>
<div id="outline-container-importing-ecmascript-modules" class="outline-3">
<a href="#importing-ecmascript-modules"><h3 id="importing-ecmascript-modules" class="cr-self-reference ">Importing ECMAScript Modules</h3></a>
<div class="outline-text-3" id="text-importing-ecmascript-modules">
<p>
The <code>require-js</code> function can only import CommonJS modules. More and more projects are choosing ECMAScript modules over CommonJS modules these days. However, implementing an importing mechanism for ECMAScript modules is entirely feasible. GraalJS provides a <code>js.esm-eval-returns-exports</code> option, with this option enabled, we can import a ECMAScript module by loading the source file. However, it will take some time to write support for things like <code>exports</code> fields in <code>package.json</code>.
</p>
</div>
</div>
<div id="outline-container-using-javascript-array-in-clojure" class="outline-3">
<a href="#using-javascript-array-in-clojure"><h3 id="using-javascript-array-in-clojure" class="cr-self-reference ">Using JavaScript array in Clojure</h3></a>
<div class="outline-text-3" id="text-using-javascript-array-in-clojure">
<p>
In ClojureScript, many times we can use a JavaScript array just like a ClojureScript vector (not vice versa though).
We haven't implement something similar to this.
</p>

<div class="org-src-container">
<pre class="cr-highlighted"><code class="lang-clojure"><html><head></head><body><span class="hljs-comment">;; ClojureScript</span>
(<span class="hljs-name"><span class="hljs-built_in">map</span></span> (<span class="hljs-name"><span class="hljs-built_in">fn</span></span> [x] (<span class="hljs-name"><span class="hljs-built_in">*</span></span> x <span class="hljs-number">2</span>)) #js [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>])
<span class="hljs-comment">;; (2 4 6)</span>
</body></html></code></pre>
</div>
</div>
</div>
</div>
<div id="outline-container-to-be-continue..." class="outline-2">
<a href="#to-be-continue..."><h2 id="to-be-continue..." class="cr-self-reference ">To Be Continue…</h2></a>
<div class="outline-text-2" id="text-to-be-continue...">
<p>
Despite the limitations, I still believe this approach is something worth exploring. I'm planning on making an isomorphic React demonstration with Server Side Rendering and Client Side Rehydration using only a thin wrapper over React and React DOM Server (instead of reimplementing the SSR logics on the JVM). The code presented here is also expanded and refined when I'm writing the blog, and the code is open sourced at <a href="https://github.com/imakira/js4clj">imakira/js4clj</a>.
</p>
</div>
</div>
</div><div class="mt-4"><div class="border-neutral-400 border-l-2 text-[1.05rem] 2xl:text-lg w-78 fixed right-0 top-[13.5rem] z-200 max-h-[80vh] overflow-y-auto select-none hidden md:block xl:top-36  2xl:w-96"><ul><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-4" href="#basic-setup-and-a-hello-world-program"><span>Basic Setup and a Hello World Program</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-4" href="#working-with-javascript-libraries"><span>Working With JavaScript Libraries</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-4" href="#ease-things-with-helper-functions,-macros-and-more"><span>Ease Things With Helper Functions, Macros and More</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-8" href="#mapping-between-clojure-and-polyglot-values"><span>Mapping between Clojure and Polyglot Values</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-12" href="#primitive-types"><span>Primitive Types</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-12" href="#functions"><span>Functions</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-12" href="#mapping_objects"><span>Objects</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-8" href="#dot-macros-and-~set!~"><span>Dot Macros and  set!</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-8" href="#~require~-command"><span>require  command</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-8" href="#bonus:-special-~js~-namespace"><span>Bonus: Special  js  namespace</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-4" href="#limitations"><span>Limitations</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-8" href="#functionalities-specific-to-an-environment"><span>Functionalities specific to an environment</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-8" href="#multithreading-and-the-~js~-namespace"><span>Multithreading and the  js  namespace</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-8" href="#shorthands-for-dot-macros"><span>Shorthands for dot macros</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-8" href="#importing-ecmascript-modules"><span>Importing ECMAScript Modules</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-8" href="#using-javascript-array-in-clojure"><span>Using JavaScript array in Clojure</span></a></div></div></div></li><li class="my-1 list-inside text-neutral-600"><div class="relative group"><div class="absolute w-0 h-full group-hover:bg-sky-200 group-hover:bg-opacity-70 group-hover:w-full group-hover:h-full transition-all duration-300"></div><div class="relative w-full h-full"><div class="group w-full h-full"><a class="h-12 transition-all w-full h-full inline-block flex flex-col justify-center group-hover:text-[#0260B3] pl-4" href="#to-be-continue..."><span>To Be Continue…</span></a></div></div></div></li></ul></div></div></div></div></main></div></div><script>window.__server_path = "/"</script><script>window.__cerulean_rehydrate = true;</script><script>globalThis["user-config"] = {"title":"Coruscation.net","cname":"coruscation.net","root-url":"https://coruscation.net","author":"imakira","links":{"rss":{"href":"/atom.xml","external?":true},"github":{"href":"https://github.com/imakira/cerulean"},"email":{"path":"me","domain":"coruscation.net"}},"navigation":{"home":{"text":"HOME","href":"/"},"about":{"text":"ABOUT","href":"https://github.com/imakira"},"projects":{"text":"PROJECTS","href":"https://github.com/imakira"}},"special-pages":["about"]};
globalThis["blog/experiment-with-graalvm--clojure--and-javascript"] = {"blog/orgx":false,"blog/tags":[],"blog/unlisted":false,"blog/title":"Experiment with GraalVM, Clojure, and JavaScript","blog/show-toc?":true,"blog/file-path":"/home/void/Projects/cerulean/workspace/blogs/experiment-with-graalvm-clojure-and-javascript.org","blog/author":null,"blog/email":null,"blog/description":"A common challenge when making a fullstack website using Clojure/ClojureScript is that, we are often required to use a JavaScript library on the server sid...","blog/id":"experiment-with-graalvm--clojure--and-javascript","blog/category":"Coding","blog/language":"en_US","blog/published-date":"2025-11-18T15:03:31+08:00","blog/content":"<p>\nA common challenge when making a fullstack website using Clojure/ClojureScript is that, we are often required to use a JavaScript library on the server side when doing Server Side Rendering (SSR). GraalVM/GraalJS provides a solution to run JavaScript code on the JVM. If only we could harness that power…\n</p>\n\n<p>\nThis blog describes the basic usage of GraalJS and what I managed to achieve with GraalJS and Clojure.\n</p>\n<div id=\"outline-container-basic-setup-and-a-hello-world-program\" class=\"outline-2\">\n<a href=\"#basic-setup-and-a-hello-world-program\"><h2 id=\"basic-setup-and-a-hello-world-program\" class=\"cr-self-reference \">Basic Setup and a Hello World Program</h2></a>\n<div class=\"outline-text-2\" id=\"text-basic-setup-and-a-hello-world-program\">\n<p>\nWe add the following dependencies to our <code>deps.edn</code>\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-bash\"><html><head></head><body>:deps {org.clojure/clojure {:mvn/version <span class=\"hljs-string\">&quot;1.11.1&quot;</span>}\n       org.graalvm.polyglot/polyglot {:mvn/version <span class=\"hljs-string\">&quot;25.0.1&quot;</span>}\n       org.graalvm.js/js-language {:mvn/version <span class=\"hljs-string\">&quot;25.0.1&quot;</span>}\n       org.graalvm.truffle/truffle-runtime {:mvn/version <span class=\"hljs-string\">&quot;25.0.1&quot;</span>}}\n</body></html></code></pre>\n</div>\n\n<p>\nWith the dependencies installed, we can write a Hello World program.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-name\"><span class=\"hljs-built_in\">ns</span></span> your-namespace\n  (<span class=\"hljs-symbol\">:import</span>\n   [org.graalvm.polyglot Context]))\n\n\n(<span class=\"hljs-keyword\">defonce</span> ^<span class=\"hljs-symbol\">:dynamic</span> <span class=\"hljs-title\">*context*</span>\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">-&gt;</span></span> (<span class=\"hljs-name\">Context/newBuilder</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> String [<span class=\"hljs-string\">&quot;js&quot;</span>]))\n      (<span class=\"hljs-name\">.build</span>)))\n\n(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">hello-fn</span> (<span class=\"hljs-name\">.eval</span> *context*\n                     <span class=\"hljs-string\">&quot;js&quot;</span>\n                     <span class=\"hljs-string\">&quot;(function (name) {console.log('hello '+name)})&quot;</span>))\n\n(<span class=\"hljs-name\">.executeVoid</span> hello-fn (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> String [<span class=\"hljs-string\">&quot;world!&quot;</span>])) <span class=\"hljs-comment\">;; output: hello world!</span>\n</body></html></code></pre>\n</div>\n\n<p>\nAll kinds of JavaScript values are represented as <code>org.graalvm.polyglot.Value</code> objects by GraalJS. In the above example the <code>(.eval ...)</code> calling returns a executable <code>polyglot.Value</code>.\n</p>\n\n<p>\nWe can check if it is an executable by calling the <code>.canExecute()</code> method.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-name\">.canExecute</span> hello-fn) <span class=\"hljs-comment\">;; true</span>\n</body></html></code></pre>\n</div>\n\n<p>\nWe can invoke the executable by calling the <code>.execute()</code> method or the <code>.executeVoid()</code> method. Their difference is that latter one doesn't have a return value.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-name\">.executeVoid</span> hello-fn (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> Object [<span class=\"hljs-string\">&quot;world&quot;</span>])) <span class=\"hljs-comment\">;; output: hello world</span>\n\n(<span class=\"hljs-name\">.executeVoid</span> hello-fn (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> Object [<span class=\"hljs-string\">&quot;graaljs&quot;</span>])) <span class=\"hljs-comment\">;; output: hello graaljs</span>\n</body></html></code></pre>\n</div>\n\n<p>\nYou can check if a <code>polyglot.Value</code> object is of a certain type by using methods starting with <code>.is</code>, and convert the <code>Value</code> object to native Java value with methods starting with <code>.as</code>. For example:\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">integer-one</span> (<span class=\"hljs-name\">.eval</span> *context* <span class=\"hljs-string\">&quot;js&quot;</span> <span class=\"hljs-string\">&quot;1&quot;</span>)) <span class=\"hljs-comment\">;; #object[org.graalvm.polyglot.Value 0x3583d830 &quot;1&quot;]</span>\n(<span class=\"hljs-name\">.isNumber</span> integer-one) <span class=\"hljs-comment\">;; true</span>\n(<span class=\"hljs-name\">.asLong</span> integer-one) <span class=\"hljs-comment\">;; 1</span>\n(<span class=\"hljs-name\">.isString</span> integer-one) <span class=\"hljs-comment\">;; false</span>\n(<span class=\"hljs-name\">.asString</span> integer-one) <span class=\"hljs-comment\">;; ERROR: Unhandled java.lang.ClassCastException</span>\n</body></html></code></pre>\n</div>\n\n<p>\nTo handle JavaScript objects, we have <code>.newInstance()</code> for instantiating an Object, <code>.invokeMember()</code> for calling a method, <code>.getMemberKeys()</code>, <code>.getMember()</code> and <code>.putMember()</code> for accessing properties of an object.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body><span class=\"hljs-comment\">;; We can access top-level JavaScript variables using the (.getBindings *context* &quot;js&quot;).</span>\n<span class=\"hljs-comment\">;; It returns a polyglot.Value object from which we can retrieve builtin</span>\n<span class=\"hljs-comment\">;;   JavaScript functions and objects.</span>\n(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">Array</span> (<span class=\"hljs-name\">.getMember</span> (<span class=\"hljs-name\">.getBindings</span> *context* <span class=\"hljs-string\">&quot;js&quot;</span>) <span class=\"hljs-string\">&quot;Array&quot;</span>))\n\n<span class=\"hljs-comment\">;; create an Array</span>\n(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">arr</span> (<span class=\"hljs-name\">.newInstance</span> Array (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> Object [<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span>])))\n\n(<span class=\"hljs-name\">print</span> arr) <span class=\"hljs-comment\">;; #object[org.graalvm.polyglot.Value 0x2dd585ca &quot;(3)[1, 2, 3]&quot;]</span>\n\n<span class=\"hljs-comment\">;; pop a value and cast it to Long</span>\n(<span class=\"hljs-name\">.asLong</span> (<span class=\"hljs-name\">.invokeMember</span> arr <span class=\"hljs-string\">&quot;pop&quot;</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> Object []))) <span class=\"hljs-comment\">;; 3</span>\n\n(<span class=\"hljs-name\">print</span> arr) <span class=\"hljs-comment\">;; #object[org.graalvm.polyglot.Value 0x27e1e162 (2)[1, 2]]</span>\n</body></html></code></pre>\n</div>\n</div>\n</div>\n<div id=\"outline-container-working-with-javascript-libraries\" class=\"outline-2\">\n<a href=\"#working-with-javascript-libraries\"><h2 id=\"working-with-javascript-libraries\" class=\"cr-self-reference \">Working With JavaScript Libraries</h2></a>\n<div class=\"outline-text-2\" id=\"text-working-with-javascript-libraries\">\n<p>\nGraalJS has an option to provide a <code>require</code> function, with which we can import CommonJS JavaScript modules. The option isn't enabled by default. To enable it, we need to change the definition of <code>*context*</code> to the following:\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defonce</span> ^<span class=\"hljs-symbol\">:dynamic</span> <span class=\"hljs-title\">*context*</span>\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">-&gt;</span></span> (<span class=\"hljs-name\">Context/newBuilder</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> String ))\n      (<span class=\"hljs-name\">.allowExperimentalOptions</span> <span class=\"hljs-literal\">true</span>)\n      (<span class=\"hljs-name\">.options</span> (<span class=\"hljs-name\">HashMap.</span>\n                 {<span class=\"hljs-string\">&quot;js.commonjs-require&quot;</span> <span class=\"hljs-string\">&quot;true&quot;</span>\n                  <span class=\"hljs-string\">&quot;js.commonjs-require-cwd&quot;</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> (<span class=\"hljs-name\">System/getProperty</span> <span class=\"hljs-string\">&quot;user.dir&quot;</span>)\n                                                 <span class=\"hljs-string\">&quot;/node_modules&quot;</span>)}))\n      (<span class=\"hljs-name\">.allowIO</span> <span class=\"hljs-literal\">true</span>)\n      (<span class=\"hljs-name\">.build</span>)))\n</body></html></code></pre>\n</div>\n\n<p>\nHere we use as <code>commonjs-require-cwd</code>'s value. It tells GraalJS to find JavaScript modules under the <code>node_modules</code> folder in the project root.\n</p>\n\n<p>\nWe can then install JavaScript libraries using npm under the project root. Here I use &quot;luxon&quot; as an example.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-bash\"><html><head></head><body>npm init\nnpm install luxon\n</body></html></code></pre>\n</div>\n\n<p>\nWe can then import the module by using <code>require</code> function.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">luxon</span> (<span class=\"hljs-name\">.eval</span> *context* <span class=\"hljs-string\">&quot;js&quot;</span> <span class=\"hljs-string\">&quot;require('luxon')&quot;</span>))\n</body></html></code></pre>\n</div>\n\n<p>\nWe can access the resulting module with the <code>.getMember()</code> method.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">DateTime</span> (<span class=\"hljs-name\">.getMember</span> luxon <span class=\"hljs-string\">&quot;DateTime&quot;</span>))\n</body></html></code></pre>\n</div>\n\n<p>\nNow we have the <code>DateTime</code> class from the <code>luxon</code> library, let's try to turn it into something useful:\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defn</span> <span class=\"hljs-title\">now</span> []\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">-&gt;</span></span> DateTime\n      <span class=\"hljs-comment\">;; DateTime.now() returns a DateTime object</span>\n      (<span class=\"hljs-name\">.invokeMember</span> <span class=\"hljs-string\">&quot;now&quot;</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> Object []))\n      <span class=\"hljs-comment\">;; We call the .toString method to convert the object</span>\n      <span class=\"hljs-comment\">;;    into a JavaScript String</span>\n          (<span class=\"hljs-name\">.invokeMember</span> <span class=\"hljs-string\">&quot;toString&quot;</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> Object []))\n      <span class=\"hljs-comment\">;; then we convert the result into a Java String</span>\n          (<span class=\"hljs-name\">.asString</span>)))\n\n<span class=\"hljs-comment\">;; Let's try to call the function</span>\n\n(<span class=\"hljs-name\">now</span>) <span class=\"hljs-comment\">;; &quot;2025-11-15T16:56:49.798+08:00&quot;</span>\n(<span class=\"hljs-name\">now</span>) <span class=\"hljs-comment\">;; &quot;2025-11-15T16:57:01.961+08:00&quot;</span>\n\n</body></html></code></pre>\n</div>\n\n<p>\nWe wrapped the details of interop between Clojure and JavaScript in a Clojure function <code>now</code>. Now if we want to get the current time string from the <code>luxon</code> library, we can just call the <code>now</code> function. The interop is still something quite cumbersome to do, however. In this blog I will show you how to turn it into something way more concise using the macros and other facilities provided by Clojure. Here is a glimpse of it:\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-name\">js..</span> lux/DateTime now toString) <span class=\"hljs-comment\">;; &quot;2025-11-15T17:04:38.574+08:00&quot;</span>\n</body></html></code></pre>\n</div>\n</div>\n</div>\n<div id=\"outline-container-ease-things-with-helper-functions,-macros-and-more\" class=\"outline-2\">\n<a href=\"#ease-things-with-helper-functions,-macros-and-more\"><h2 id=\"ease-things-with-helper-functions,-macros-and-more\" class=\"cr-self-reference \">Ease Things With Helper Functions, Macros and More</h2></a>\n<div class=\"outline-text-2\" id=\"text-ease-things-with-helper-functions,-macros-and-more\">\n<p>\nYou must have noticed the definition of the <code>now</code> function in the previous example is quite clumsy. In ClojureScript we have the following things that can facilitate the interop between ClojureScript and JavaScript\n</p>\n<ul class=\"org-ul\">\n<li>We can require a js module just like a clojure namespace</li>\n<li>A ClojureScript function is just a JavaScript function, we can call JavaScript functions from the ClojureScript side, or we can pass ClojureScript functions to the JavaScript side.</li>\n<li>We have dot macros ( <code>.</code>, <code>..</code> and <code>.-</code> ) and <code>set!</code> to easily access properites or methods of JavaScript objects.</li>\n</ul>\n\n<p>\nTo build something on the same level is probably very hard, however, to build a demonstration of something very similar is indeed very achievable.\n</p>\n</div>\n<div id=\"outline-container-mapping-between-clojure-and-polyglot-values\" class=\"outline-3\">\n<a href=\"#mapping-between-clojure-and-polyglot-values\"><h3 id=\"mapping-between-clojure-and-polyglot-values\" class=\"cr-self-reference \">Mapping between Clojure and Polyglot Values</h3></a>\n<div class=\"outline-text-3\" id=\"text-mapping-between-clojure-and-polyglot-values\">\n<p>\nWe probably don't want to manually convert the result each time we get a value from the JavaScript side as we did in the previous examples. So we would like to put the actual JavaScript functions invoking logics into a wrapper and let the wrapper automatically convert the parameters and the return value for us. To make something like this, and since GraalJS represents each JavaScript value as a Polyglot Value, we first need to establish a mapping between Clojure types and Polyglot Types.\n</p>\n</div>\n<div id=\"outline-container-primitive-types\" class=\"outline-4\">\n<a href=\"#primitive-types\"><h4 id=\"primitive-types\" class=\"cr-self-reference \">Primitive Types</h4></a>\n<div class=\"outline-text-4\" id=\"text-primitive-types\">\n<p>\nEach time we call the <code>.execute()</code> or <code>.invokeMember()</code> method of the <code>polyglot.Value</code> class, GraalJS will convert the arguments using <code>.asValue()</code> method of <code>Context</code> class. However, we are going to wrap Clojure functions as Polyglot functions in the next section. As of now, we write a Clojure -&gt; Polyglot mapping function only calling the <code>.asValue()</code> method.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defn</span> <span class=\"hljs-title\">polyglotalize-clojure</span> [value]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cond</span></span>\n    <span class=\"hljs-comment\">;; https://www.graalvm.org/sdk/javadoc/org/graalvm/polyglot/Context.html#asValue(java.lang.Object)</span>\n    <span class=\"hljs-symbol\">:else</span>\n    (<span class=\"hljs-name\">.asValue</span> *context* value)))\n</body></html></code></pre>\n</div>\n\n<p>\nAs for the mapping from <code>polyglot.Value</code> to Clojure values, we use the various checking and converting methods described before.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defn</span> <span class=\"hljs-title\">clojurify-value</span> [^org.graalvm.polyglot.Value value]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cond</span></span> (<span class=\"hljs-name\">.isHostObject</span> value)\n        (<span class=\"hljs-name\">.asHostObject</span> value)\n\n        (<span class=\"hljs-name\">.isBoolean</span> value)\n        (<span class=\"hljs-name\">.asBoolean</span> value)\n\n        (<span class=\"hljs-name\">.isNull</span> value)\n        <span class=\"hljs-literal\">nil</span>\n\n        (<span class=\"hljs-name\">.isString</span> value)\n        (<span class=\"hljs-name\">.asString</span> value)\n\n        (<span class=\"hljs-name\">.isNumber</span> value)\n        (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cond</span></span> (<span class=\"hljs-name\">.fitsInLong</span> value)\n              (<span class=\"hljs-name\">.asLong</span> value)\n\n              (<span class=\"hljs-name\">.fitsInDouble</span> value)\n              (<span class=\"hljs-name\">.asDouble</span> value))\n\n        <span class=\"hljs-symbol\">:else</span>\n        value))\n</body></html></code></pre>\n</div>\n</div>\n</div>\n<div id=\"outline-container-functions\" class=\"outline-4\">\n<a href=\"#functions\"><h4 id=\"functions\" class=\"cr-self-reference \">Functions</h4></a>\n<div class=\"outline-text-4\" id=\"text-functions\">\n<p>\nGraalVM provides various <code>Proxy</code> objects that we can use to make Clojure objects accessible in the JavaScript environment. To wrap a function, we need to use <code>ProxyExecutable</code>.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defn</span> <span class=\"hljs-title\">wrap-clojure-fn</span> [f]\n  (<span class=\"hljs-name\">.asValue</span> *context*\n            (<span class=\"hljs-name\"><span class=\"hljs-built_in\">with-meta</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">reify</span></span> org.graalvm.polyglot.proxy.ProxyExecutable\n                         #_{<span class=\"hljs-symbol\">:clj-kondo/ignore</span> [<span class=\"hljs-symbol\">:unused-binding</span>]}\n                         <span class=\"hljs-comment\">;; we ignore `this` for now</span>\n                         (<span class=\"hljs-name\">execute</span> [this ^<span class=\"hljs-string\">&quot;[Lorg.graalvm.polyglot.Value;&quot;</span> values]\n                           (<span class=\"hljs-name\">polyglotalize-clojure</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">apply</span></span> f (<span class=\"hljs-name\"><span class=\"hljs-built_in\">map</span></span> clojurify-value values)))))\n              {<span class=\"hljs-symbol\">::raw-fn</span> f})))\n</body></html></code></pre>\n</div>\n\n<p>\nThe function takes a Clojure function as an argument, returns a Polyglot executable that we can pass to the JavaScript environment.\n</p>\n\n<p>\nIn the function body, we use <code>reify</code> to instantiate an object implementing the <code>ProxyExecutable</code> interface. We implement the <code>.execute()</code> method by applying the clojurified arguments to the original Clojure function, and convert the return value back to a Polyglot value using the two functions we wrote in the <a href=\"#primitive-types\">previous section</a>.\n</p>\n\n<p>\nIn case we want to turn the proxy object back into a clojure function (like when a JavaScript function returns the proxy object as is), we save the original Clojure function into the <a href=\"https://clojure.org/reference/metadata\">metadata</a> of the proxy object using <code>with-meta</code>. In the final step, we turn it into a Polyglot Value using <code>.asValue</code> method from <code>Context</code>.\n</p>\n\n<p>\nWrapping functions from JavaScript follows a similar logic.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defn</span> <span class=\"hljs-title\">wrap-polyglot-executable</span> [^org.graalvm.polyglot.Value obj]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">with-meta</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">fn</span></span> [&amp; args]\n               (<span class=\"hljs-name\">clojurify-value</span> (<span class=\"hljs-name\">.execute</span> obj (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> Object (<span class=\"hljs-name\"><span class=\"hljs-built_in\">map</span></span> polyglotalize-clojure args)))))\n    {<span class=\"hljs-symbol\">::raw-value</span> obj}))\n</body></html></code></pre>\n</div>\n\n<p>\nHere, we also save a reference to the original JavaScript function in the metadata. However, it serves a much more important role: In JavaScript, a function is like any object, it can have all kinds of properties. Therefore, after wrapping a JavaScript function as a Clojure function, we may still need to access its other properties. To do this, we save the original function in the metadata and retrieve it if necessary.\n</p>\n\n<p>\nWith these two functions defined, we can then augmented our two mapping functions.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defn</span> <span class=\"hljs-title\">polyglotalize-clojure</span> [value]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cond</span></span> (<span class=\"hljs-symbol\">::raw-value</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">meta</span></span> value))\n        (<span class=\"hljs-symbol\">::raw-value</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">meta</span></span> value))\n\n        (<span class=\"hljs-name\"><span class=\"hljs-built_in\">fn?</span></span> value)\n        (<span class=\"hljs-name\">wrap-clojure-fn</span> value)\n\n        <span class=\"hljs-symbol\">:else</span>\n        <span class=\"hljs-comment\">;; https://www.graalvm.org/sdk/javadoc/org/graalvm/polyglot/Context.html#asValue(java.lang.Object)</span>\n        (<span class=\"hljs-name\">.asValue</span> *context* value)))\n</body></html></code></pre>\n</div>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defn</span> <span class=\"hljs-title\">clojurify-value</span> [^org.graalvm.polyglot.Value value]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cond</span></span>\n\n    (<span class=\"hljs-name\">.isProxyObject</span> value)\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [prox-obj (<span class=\"hljs-name\">.asProxyObject</span> value)]\n      (<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> (<span class=\"hljs-symbol\">::raw-fn</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">meta</span></span> prox-obj))\n        (<span class=\"hljs-symbol\">::raw-fn</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">meta</span></span> prox-obj))\n        prox-obj))\n\n    <span class=\"hljs-comment\">;;</span>\n    <span class=\"hljs-comment\">;; ... omitted</span>\n    <span class=\"hljs-comment\">;;</span>\n\n    (<span class=\"hljs-name\">.canExecute</span> value) \n    (<span class=\"hljs-name\">wrap-polyglot-executable</span> value)\n\n    <span class=\"hljs-symbol\">:else</span>\n    value))\n</body></html></code></pre>\n</div>\n\n<p>\nWith these two facilities created, we already achieve something very interesting.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">hello</span> (<span class=\"hljs-name\">clojurify-value</span> (<span class=\"hljs-name\">.eval</span> *context* <span class=\"hljs-string\">&quot;js&quot;</span> <span class=\"hljs-string\">&quot;(function (name){console.log(`hello ${name}`)})&quot;</span>)))\n\n(<span class=\"hljs-name\">hello</span> <span class=\"hljs-string\">&quot;world&quot;</span>) <span class=\"hljs-comment\">;; output: hello world</span>\n(<span class=\"hljs-name\">hello</span> <span class=\"hljs-string\">&quot;graaljs&quot;</span>) <span class=\"hljs-comment\">;; output: hello graaljs</span>\n\n(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">to-array</span> (<span class=\"hljs-name\">clojurify-value</span>\n               (<span class=\"hljs-name\">.eval</span> *context* <span class=\"hljs-string\">&quot;js&quot;</span> <span class=\"hljs-string\">&quot;(function (...args){return Array.from(args);})&quot;</span>)))\n\n(<span class=\"hljs-name\"><span class=\"hljs-built_in\">to-array</span></span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\">;; #object[org.graalvm.polyglot.Value 0x26e3da6b &quot;(4)[1, 2, 3, 4]&quot;]</span>\n\n(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">join</span> (<span class=\"hljs-name\">clojurify-value</span>\n           (<span class=\"hljs-name\">.eval</span> *context* <span class=\"hljs-string\">&quot;js&quot;</span> <span class=\"hljs-string\">&quot;(function (s, ...args){return args.join(s);})&quot;</span>)))\n\n(<span class=\"hljs-name\">join</span> <span class=\"hljs-string\">&quot;,&quot;</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\">;; &quot;1,2,3,4&quot;</span>\n</body></html></code></pre>\n</div>\n\n<p>\nAs you have seen, we can now call a JavaScript function just like a Clojure function. Return values of primitive types will also be automatically converted back to Clojure values.\n</p>\n\n<p>\nWe can also pass Clojure functions to the JavaScript side:\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">sum-term</span>\n  (<span class=\"hljs-name\">clojurify-value</span>\n   (<span class=\"hljs-name\">.eval</span> *context* <span class=\"hljs-string\">&quot;js&quot;</span> <span class=\"hljs-string\">&quot;let sum = (term, a, b) =&gt; (a&gt;b)? 0 : term(a) + sum(term, a+1,b); sum&quot;</span>)))\n\n<span class=\"hljs-comment\">;; (sum-integers a b) calculate the sum of integers from `a` to `b` (inclusive)</span>\n(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">sum-integers</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">partial</span></span> sum-term identity))\n(<span class=\"hljs-name\">sum-integers</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">10</span>) <span class=\"hljs-comment\">;; 55</span>\n\n<span class=\"hljs-comment\">;; (sum-cubes a b) calculates the sum of cubes of integers from `a` to `b` (inclusive)</span>\n(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">sum-cubes</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">partial</span></span> sum-term (<span class=\"hljs-name\"><span class=\"hljs-built_in\">fn</span></span> [x] (<span class=\"hljs-name\"><span class=\"hljs-built_in\">*</span></span> x x x))))\n(<span class=\"hljs-name\">sum-cubes</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">10</span>) <span class=\"hljs-comment\">;; 3025</span>\n</body></html></code></pre>\n</div>\n</div>\n</div>\n<div id=\"outline-container-mapping_objects\" class=\"outline-4\">\n<a href=\"#mapping_objects\"><h4 id=\"mapping_objects\" class=\"cr-self-reference \">Objects</h4></a>\n<div class=\"outline-text-4\" id=\"text-mapping_objects\">\n<p>\nRougly similar to ClojureScript, We don't do mapping for objects other than those of primitives types and functions. However, in the <code>clojurify-value</code> function, we wrap all JavaScript functions into Clojure functions and save the reference in the metadata, and as I have explained there, a JavaScript function may have other properties we want to access. Thus, in each place where a Clojure function wrapping a JavaScript function can be taken as arguments, we cannot use methods from <code>polyglot.Value</code>. Instead, we define helper functions that will wrap the arguments if necessary and then call the target method.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defn</span> <span class=\"hljs-title\">polyglot-value</span> [obj]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">or</span></span> (<span class=\"hljs-symbol\">::raw-value</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">meta</span></span> obj))\n      (<span class=\"hljs-name\"><span class=\"hljs-built_in\">and</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">instance?</span></span> org.graalvm.polyglot.Value obj)\n           obj)))\n\n(<span class=\"hljs-keyword\">defn-</span> <span class=\"hljs-title\">to-camel-style</span> [s]\n  (<span class=\"hljs-name\">string/replace</span> s <span class=\"hljs-regex\">#&quot;-([a-z])&quot;</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">fn</span></span> [g]\n                                  (<span class=\"hljs-name\">.toUpperCase</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">second</span></span> g)))))\n\n(<span class=\"hljs-keyword\">defmacro</span> <span class=\"hljs-title\">define-unwrap-executable-alias</span>\n  {<span class=\"hljs-symbol\">:clj-kondo/lint-as</span> 'clojure.core/declare}\n  [name &amp; args]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [docstring? (<span class=\"hljs-name\"><span class=\"hljs-built_in\">string?</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">first</span></span> args))\n        docstring (<span class=\"hljs-name\"><span class=\"hljs-built_in\">when</span></span> docstring? (<span class=\"hljs-name\"><span class=\"hljs-built_in\">first</span></span> args))\n        args (<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> docstring? (<span class=\"hljs-name\"><span class=\"hljs-built_in\">second</span></span> args) (<span class=\"hljs-name\"><span class=\"hljs-built_in\">first</span></span> args))\n        obj 'obj\n        [arglist [_ vararg]] (<span class=\"hljs-name\"><span class=\"hljs-built_in\">split-with</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">fn</span></span> [x] (<span class=\"hljs-name\"><span class=\"hljs-built_in\">not</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">=</span></span> x '&amp;))) args)] \n    `(<span class=\"hljs-keyword\">defn</span> ~<span class=\"hljs-title\">name</span> {<span class=\"hljs-symbol\">:doc</span> ~docstring} [~obj ~@arglist ~@(<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> vararg `[&amp; ~vararg] [])]\n       (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [~obj (<span class=\"hljs-name\"><span class=\"hljs-built_in\">or</span></span> (<span class=\"hljs-name\">polyglot-value</span> ~obj)\n                      ~obj)]\n         (~(<span class=\"hljs-name\"><span class=\"hljs-built_in\">symbol</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> <span class=\"hljs-string\">&quot;.&quot;</span> (<span class=\"hljs-name\">to-camel-style</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> name))))\n          ~obj \n          ~@arglist\n          ~@(<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> vararg\n              [`(<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> Object ~vararg)]\n              []))))))\n\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> get-meta-object)\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> is-meta-object)\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> get-meta-qualified-name)\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> has-meta-parents)\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> has-array-elements)\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> get-meta-parents)\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> get-member [^String identifier])\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> put-member [^String identifier ^Object value])\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> get-member-keys)\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> new-instance [&amp; args])\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> can-invoke-member [^String s])\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> invoke-member [^String method &amp; args])\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> can-instantiate)\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> canExecute)\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> execute [&amp; args])\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> executeVoid [&amp; args])\n</body></html></code></pre>\n</div>\n\n<p>\nWe wrote a macro for this purpose. The macro takes a function name and a parameter list as arguments and defines a function with the name and parameters.\nThe function defined by the macro retrieves the reference from the metadata if necessary, then calls a method by the name converted from the function name and with arguments from the parameter list.\n</p>\n\n<p>\nOne nice bonus is that the generated functions assembles all the variadic arguments into an <code>Object[]</code>, saving us from calling <code>(into-arry Object)</code> manually if we need to call a method with variadic arguments.\n</p>\n\n<p>\nPreviously we need to do this:\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-name\">.newInstance</span> (<span class=\"hljs-name\">.eval</span> *context* <span class=\"hljs-string\">&quot;js&quot;</span> <span class=\"hljs-string\">&quot;Array&quot;</span>) (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> Object [<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span>]))\n<span class=\"hljs-comment\">;; #object[org.graalvm.polyglot.Value 0x65b337ef &quot;(3)[1, 2, 3]&quot;]</span>\n</body></html></code></pre>\n</div>\n\n<p>\nNow we just need to do this:\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-name\">new-instance</span> (<span class=\"hljs-name\">.eval</span> *context* <span class=\"hljs-string\">&quot;js&quot;</span> <span class=\"hljs-string\">&quot;Array&quot;</span>) <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span>)\n<span class=\"hljs-comment\">;; #object[org.graalvm.polyglot.Value 0xfdabe76 &quot;(3)[1, 2, 3]&quot;]</span>\n</body></html></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div id=\"outline-container-dot-macros-and-~set!~\" class=\"outline-3\">\n<a href=\"#dot-macros-and-~set!~\"><h3 id=\"dot-macros-and-~set!~\" class=\"cr-self-reference \">Dot Macros and <code>set!</code></h3></a>\n<div class=\"outline-text-3\" id=\"text-dot-macros-and-~set!~\">\n<p>\nIn ClojureScript we have dots special forms or macros like <code>.</code>,  <code>.-</code> and <code>..</code> for accessing properties or calling methods of JavaScript objects.\n</p>\n\n<p>\nWe can relatively easily implement them using macros.\n</p>\n\n<blockquote>\n<p>\nThere are also <code>(.method obj)</code> <code>(.-property obj)</code> as shorthands for <code>(. obj method)</code> and <code>(.- obj property)</code> in ClojureScript. However, implementing them would be really difficult if not impossible.\n</p>\n</blockquote>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defmacro</span> <span class=\"hljs-title\">js.</span>\n  {<span class=\"hljs-symbol\">:clj-kondo/ignore</span> [<span class=\"hljs-symbol\">:unresolved-symbol</span> <span class=\"hljs-symbol\">:type-mismatch</span>]}\n  [obj method &amp; args]\n  `(<span class=\"hljs-name\">clojurify-value</span>\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">apply</span></span> invoke-member ~obj ~(<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> method)\n           <span class=\"hljs-comment\">;; evaluate args before passing them to polyglotalize-clojure</span>\n           (<span class=\"hljs-name\"><span class=\"hljs-built_in\">map</span></span> polyglotalize-clojure (<span class=\"hljs-name\"><span class=\"hljs-built_in\">list</span></span> ~@args)))))\n\n\n(<span class=\"hljs-keyword\">defmacro</span> <span class=\"hljs-title\">js.-</span>\n  {<span class=\"hljs-symbol\">:clj-kondo/ignore</span> [<span class=\"hljs-symbol\">:unresolved-symbol</span> <span class=\"hljs-symbol\">:type-mismatch</span>]}\n  [obj field]\n  `(<span class=\"hljs-name\">#'clojurify-value</span> (<span class=\"hljs-name\">get-member</span> ~obj ~(<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> field))))\n</body></html></code></pre>\n</div>\n\n<p>\nThe <code>invoke-member</code> and <code>get-member</code> helper functions are defined in the <a href=\"#mapping_objects\">previous section</a>.\n</p>\n\n<p>\nWith these two defined, we can write the more complicated macro <code>js..</code> based on them.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defmacro</span> <span class=\"hljs-title\">js..</span>\n  {<span class=\"hljs-symbol\">:clj-kondo/ignore</span> [<span class=\"hljs-symbol\">:unresolved-symbol</span> <span class=\"hljs-symbol\">:type-mismatch</span>]}\n  [obj &amp; args]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">empty?</span></span> args)\n    obj\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [curr# (<span class=\"hljs-name\"><span class=\"hljs-built_in\">first</span></span> args)\n          rest# (<span class=\"hljs-name\"><span class=\"hljs-built_in\">rest</span></span> args)]\n      `(<span class=\"hljs-name\">js..</span> ~(<span class=\"hljs-name\"><span class=\"hljs-built_in\">cond</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">seq?</span></span> curr#)\n                    `(<span class=\"hljs-name\">js.</span> ~obj ~(<span class=\"hljs-name\"><span class=\"hljs-built_in\">first</span></span> curr#) ~@(<span class=\"hljs-name\"><span class=\"hljs-built_in\">rest</span></span> curr#))\n\n                    (<span class=\"hljs-name\">.startsWith</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> curr#)\n                                 <span class=\"hljs-string\">&quot;-&quot;</span>)\n                    `(<span class=\"hljs-name\">js.-</span> ~obj ~(<span class=\"hljs-name\">subs</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> curr#) <span class=\"hljs-number\">1</span>))\n\n                    <span class=\"hljs-symbol\">:else</span>\n                    `(<span class=\"hljs-name\">js.</span> ~obj ~curr#))\n         ~@rest#))))\n</body></html></code></pre>\n</div>\n\n<p>\nFinally, we will implement the <code>set!</code> macro.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defmacro</span> <span class=\"hljs-title\">js-set!</span> [dot-form value]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">assert</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">seq?</span></span> dot-form) <span class=\"hljs-string\">&quot;First argument must be in the form of `(js.. obj -field)` or (js.- obj field)&quot;</span>)\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [[op &amp; args] dot-form]\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">assert</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">or</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">=</span></span> op 'js..)\n                (<span class=\"hljs-name\"><span class=\"hljs-built_in\">=</span></span> op 'js.-))\n            <span class=\"hljs-string\">&quot;First argument to js-set! must start with either `js..` or `js.-`&quot;</span>)\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [remove-hyphen (<span class=\"hljs-name\"><span class=\"hljs-built_in\">=</span></span> op 'js..)\n          lst (<span class=\"hljs-name\"><span class=\"hljs-built_in\">last</span></span> args)\n          last-removed (<span class=\"hljs-name\"><span class=\"hljs-built_in\">drop-last</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into</span></span> [op] args))]\n      `(<span class=\"hljs-name\">put-member</span> ~(<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">=</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">count</span></span> last-removed) <span class=\"hljs-number\">2</span>)\n                      (<span class=\"hljs-name\"><span class=\"hljs-built_in\">second</span></span> last-removed)\n                      last-removed)\n                   ~(<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> remove-hyphen\n                      (<span class=\"hljs-name\">subs</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> lst) <span class=\"hljs-number\">1</span>)\n                      (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> lst))\n                   ~value))))\n</body></html></code></pre>\n</div>\n\n<p>\nLet's go back to the <code>luxon</code> example mentioned in the beginning of this blog and check what we can do with these newly defined tools.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">luxon</span> (<span class=\"hljs-name\">.eval</span> *context* <span class=\"hljs-string\">&quot;js&quot;</span> <span class=\"hljs-string\">&quot;require('luxon')&quot;</span>))\n\n(<span class=\"hljs-name\">js..</span> luxon -DateTime now toString) <span class=\"hljs-comment\">;; &quot;2025-11-14T16:48:11.324+08:00&quot;</span>\n</body></html></code></pre>\n</div>\n\n<p>\nCompare it to the snippet I showed at the end of the first section:\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-name\">js..</span> lux/DateTime now toString)\n</body></html></code></pre>\n</div>\n\n<p>\nThe only thing lacking is a <code>require</code> mechanism, which is what we are going to implement in the next section.\n</p>\n</div>\n</div>\n<div id=\"outline-container-~require~-command\" class=\"outline-3\">\n<a href=\"#~require~-command\"><h3 id=\"~require~-command\" class=\"cr-self-reference \"><code>require</code> command</h3></a>\n<div class=\"outline-text-3\" id=\"text-~require~-command\">\n<p>\nOn the JavaScript side, the <code>require()</code> function returns an object from which we can access its exported variables or functions.\n</p>\n\n<p>\nOn the Clojure side, we can dynamically create a namespace with the <code>create-ns</code> function. After that we can make all the variables from the module object accessible in the newly created namespace with the <code>intern</code> function.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defn-</span> <span class=\"hljs-title\">require-module</span> [name]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">-&gt;</span></span> *context*\n      (<span class=\"hljs-name\">.eval</span> <span class=\"hljs-string\">&quot;js&quot;</span>\n             (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> <span class=\"hljs-string\">&quot;require('&quot;</span> name <span class=\"hljs-string\">&quot;')&quot;</span>))))\n\n(<span class=\"hljs-keyword\">defn-</span> <span class=\"hljs-title\">parse-flags</span> [args]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">loop</span></span> [args (<span class=\"hljs-name\"><span class=\"hljs-built_in\">lazy-seq</span></span> args)\n         result (<span class=\"hljs-name\"><span class=\"hljs-built_in\">hash-map</span></span>)]\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">empty?</span></span> args)\n      result\n      (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [curr (<span class=\"hljs-name\"><span class=\"hljs-built_in\">first</span></span> args)\n            rst (<span class=\"hljs-name\"><span class=\"hljs-built_in\">rest</span></span> args)]\n        (<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">or</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">keyword?</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">first</span></span> rst))\n                (<span class=\"hljs-name\"><span class=\"hljs-built_in\">empty?</span></span> rst))\n          (<span class=\"hljs-name\"><span class=\"hljs-built_in\">recur</span></span> rst (<span class=\"hljs-name\"><span class=\"hljs-built_in\">assoc</span></span> result curr <span class=\"hljs-literal\">true</span>))\n          (<span class=\"hljs-name\"><span class=\"hljs-built_in\">recur</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">rest</span></span> rst)\n                 (<span class=\"hljs-name\"><span class=\"hljs-built_in\">assoc</span></span> result curr (<span class=\"hljs-name\"><span class=\"hljs-built_in\">first</span></span> rst))))))))\n\n(<span class=\"hljs-keyword\">defn-</span> <span class=\"hljs-title\">normalize-module-name</span> [name]\n  (<span class=\"hljs-name\">s/replace</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> name) <span class=\"hljs-regex\">#&quot;/&quot;</span> <span class=\"hljs-string\">&quot;.&quot;</span>))\n\n(<span class=\"hljs-keyword\">defn</span> <span class=\"hljs-title\">require-js</span>\n  {<span class=\"hljs-symbol\">:clj-kondo/lint-as</span> 'clojure.core/require}\n  [[module-name &amp; flags] &amp; coll]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [flag-map (<span class=\"hljs-name\">parse-flags</span> flags)\n        module (<span class=\"hljs-name\">require-module</span> module-name)\n        alias-name (<span class=\"hljs-symbol\">:as</span> flag-map)\n        qualified-module-name (<span class=\"hljs-name\"><span class=\"hljs-built_in\">symbol</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> <span class=\"hljs-string\">&quot;js4clj.modules.&quot;</span> (<span class=\"hljs-name\">normalize-module-name</span> module-name)))]\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">create-ns</span></span> qualified-module-name)\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">doseq</span></span> [k (<span class=\"hljs-name\">.getMemberKeys</span> module)]\n      (<span class=\"hljs-name\"><span class=\"hljs-built_in\">intern</span></span> qualified-module-name\n              (<span class=\"hljs-name\"><span class=\"hljs-built_in\">symbol</span></span> k)\n              (<span class=\"hljs-name\">clojurify-value</span> (<span class=\"hljs-name\">.getMember</span> module k))))\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">when</span></span> alias-name\n      (<span class=\"hljs-name\"><span class=\"hljs-built_in\">alias</span></span> alias-name qualified-module-name)))\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">when</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">seq</span></span> coll)\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">apply</span></span> require-js coll)))\n</body></html></code></pre>\n</div>\n\n<p>\n<code>(require-js '[luxon :as lux])</code> is now all we need to require a JavaScript module.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-name\">require-js</span> '[luxon <span class=\"hljs-symbol\">:as</span> lux])\n\n(<span class=\"hljs-name\">js..</span> lux/DateTime now toString) <span class=\"hljs-comment\">;; &quot;2025-11-14T17:08:40.045+08:00&quot;</span>\n</body></html></code></pre>\n</div>\n\n<p>\nLet's try some more examples:\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-name\">js..</span> lux/DateTime (<span class=\"hljs-name\">fromISO</span> <span class=\"hljs-string\">&quot;2017-05-15T08:30:00&quot;</span>) -year) <span class=\"hljs-comment\">;; 2017</span>\n\n<span class=\"hljs-comment\">;; or write it as</span>\n(<span class=\"hljs-name\"><span class=\"hljs-built_in\">-&gt;</span></span> lux/DateTime\n    (<span class=\"hljs-name\">js.</span> fromISO <span class=\"hljs-string\">&quot;2017-05-15T08:30:00&quot;</span>)\n    (<span class=\"hljs-name\">js.-</span> year)) <span class=\"hljs-comment\">;; 2017</span>\n\n(<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [now (<span class=\"hljs-name\">js.</span> lux/DateTime now)\n      later (<span class=\"hljs-name\">js.</span> lux/DateTime local <span class=\"hljs-number\">2026</span> <span class=\"hljs-number\">10</span> <span class=\"hljs-number\">12</span>)\n      i (<span class=\"hljs-name\">js.</span> lux/Interval fromDateTimes now later)]\n  (<span class=\"hljs-name\">js.</span> i length <span class=\"hljs-string\">&quot;years&quot;</span>)) <span class=\"hljs-comment\">;; 0.904136850298072</span>\n</body></html></code></pre>\n</div>\n</div>\n</div>\n<div id=\"outline-container-bonus:-special-~js~-namespace\" class=\"outline-3\">\n<a href=\"#bonus:-special-~js~-namespace\"><h3 id=\"bonus:-special-~js~-namespace\" class=\"cr-self-reference \">Bonus: Special <code>js</code> namespace</h3></a>\n<div class=\"outline-text-3\" id=\"text-bonus:-special-~js~-namespace\">\n<p>\nClojureScript provides us a <a href=\"https://cljs.github.io/api/syntax/js-namespace\">special <code>js</code> namespace</a>, from where we can use various JavaScript global objects. We can also implement something like that.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">def</span> ^<span class=\"hljs-symbol\">:dynamic</span> <span class=\"hljs-title\">*no-clojurify*</span> <span class=\"hljs-literal\">false</span>)\n\n(<span class=\"hljs-keyword\">defn-</span> <span class=\"hljs-title\">define-builtin</span> [ns primitive &amp; [alias]]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">intern</span></span> ns (<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> alias (<span class=\"hljs-name\"><span class=\"hljs-built_in\">symbol</span></span> alias) (<span class=\"hljs-name\"><span class=\"hljs-built_in\">symbol</span></span> primitive))\n          ((<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> *no-clojurify* identity clojurify-value)\n           (<span class=\"hljs-name\">.eval</span> *context* <span class=\"hljs-string\">&quot;js&quot;</span> primitive))))\n\n(<span class=\"hljs-keyword\">defmacro</span> <span class=\"hljs-title\">define-builtins</span>\n  {<span class=\"hljs-symbol\">:clj-kondo/lint-as</span> 'clojure.core/declare}\n  [ns &amp; primitives]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">create-ns</span></span> ns)\n  `(<span class=\"hljs-name\"><span class=\"hljs-built_in\">doseq</span></span> [primitive# '~primitives]\n     (<span class=\"hljs-name\">define-builtin</span> '~ns (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> primitive#))))\n\n<span class=\"hljs-comment\">;; In cljs there is also a js/undefined</span>\n<span class=\"hljs-comment\">;;\tin which (= nil js/undefined) but we can't mimic it.</span>\n<span class=\"hljs-comment\">;; Still, we need a js/undefined in case we need to do some</span>\n<span class=\"hljs-comment\">;; \tvery specific interop.</span>\n(<span class=\"hljs-name\"><span class=\"hljs-built_in\">declare</span></span> undefined)\n(<span class=\"hljs-name\">with-bindings</span> {#'*no-clojurify* <span class=\"hljs-literal\">true</span>}\n  (<span class=\"hljs-name\">define-builtin</span> 'js <span class=\"hljs-string\">&quot;undefined&quot;</span> <span class=\"hljs-string\">&quot;undefined&quot;</span>))\n\n#_{<span class=\"hljs-symbol\">:clojure-lsp/ignore</span> [<span class=\"hljs-symbol\">:clojure-lsp/unused-public-var</span>]}\n(<span class=\"hljs-name\">define-builtins</span> js\n  globalThis\n  Infinity\n  NaN\n  Object\n  Function\n  Boolean\n  Symbol\n  Error\n  Number\n  BigInt\n  Math\n  Date\n  String\n  Array\n  Map\n  Set\n  WeakMap\n  WeakSet\n  JSON\n  ArrayBuffer\n  Promise\n  console)\n</body></html></code></pre>\n</div>\n\n<p>\nWe took a special handling of <code>js/undefined</code> (note when we clojurify JavaScript values, we turn both <code>null</code> and <code>undefined</code> into <code>nil</code>), since a direct equivalent of <code>undefined</code> in JavaScript may be needed for some interops. However, <code>js/undefined</code> In ClojureScript has some special properties we can't replicate, most notably, <code>(nil? js/undefined)</code> and <code>(= js/undefined nil)</code> results in <code>true</code> in ClojureScript.\n</p>\n</div>\n</div>\n</div>\n<div id=\"outline-container-limitations\" class=\"outline-2\">\n<a href=\"#limitations\"><h2 id=\"limitations\" class=\"cr-self-reference \">Limitations</h2></a>\n<div class=\"outline-text-2\" id=\"text-limitations\">\n</div>\n<div id=\"outline-container-functionalities-specific-to-an-environment\" class=\"outline-3\">\n<a href=\"#functionalities-specific-to-an-environment\"><h3 id=\"functionalities-specific-to-an-environment\" class=\"cr-self-reference \">Functionalities specific to an environment</h3></a>\n<div class=\"outline-text-3\" id=\"text-functionalities-specific-to-an-environment\">\n<p>\nJavaScript packages are often written under the assumption that, the code will either run on a Browser or a node.js environment. Unfortunately, GraalJS only implements the ECMAScript specification, which means we have neither functions specific to node.js nor functions specific to a browser.\n</p>\n\n<p>\nFor example, we don't have <code>WebWorker</code> api from the browser, nor <code>process</code>, <code>fs</code> api from node.js.\n</p>\n</div>\n</div>\n<div id=\"outline-container-multithreading-and-the-~js~-namespace\" class=\"outline-3\">\n<a href=\"#multithreading-and-the-~js~-namespace\"><h3 id=\"multithreading-and-the-~js~-namespace\" class=\"cr-self-reference \">Multithreading and the <code>js</code> namespace</h3></a>\n<div class=\"outline-text-3\" id=\"text-multithreading-and-the-~js~-namespace\">\n<p>\nWhen writing programs in Java, we usually use blocking operations and multithreading. However, <code>polyglot.Context</code> is not thread-safe. It isn't a problem in itself, since we can spin up multiple contexts. However, variables in <code>js</code> refer to variables in a specific context. Thus, if we want to use multiple contexts, we cannot refer to variables in the <code>js</code> namespace with the current settings. We may be able to mitigate or solve this problem with dynamic bindings or using a dedicated thread for JavaScript operations.\n</p>\n</div>\n</div>\n<div id=\"outline-container-shorthands-for-dot-macros\" class=\"outline-3\">\n<a href=\"#shorthands-for-dot-macros\"><h3 id=\"shorthands-for-dot-macros\" class=\"cr-self-reference \">Shorthands for dot macros</h3></a>\n<div class=\"outline-text-3\" id=\"text-shorthands-for-dot-macros\">\n<p>\nWe have already talked about it in the <a href=\"#dot-macros-and-~set!~\">Dot Macros</a> section. In ClojureScript we can <code>(ClassName.)</code> for instantiate an instance or <code>(.method obj)</code> for invoking an method. Implementing them would be really hard if not impossible.\n</p>\n</div>\n</div>\n<div id=\"outline-container-importing-ecmascript-modules\" class=\"outline-3\">\n<a href=\"#importing-ecmascript-modules\"><h3 id=\"importing-ecmascript-modules\" class=\"cr-self-reference \">Importing ECMAScript Modules</h3></a>\n<div class=\"outline-text-3\" id=\"text-importing-ecmascript-modules\">\n<p>\nThe <code>require-js</code> function can only import CommonJS modules. More and more projects are choosing ECMAScript modules over CommonJS modules these days. However, implementing an importing mechanism for ECMAScript modules is entirely feasible. GraalJS provides a <code>js.esm-eval-returns-exports</code> option, with this option enabled, we can import a ECMAScript module by loading the source file. However, it will take some time to write support for things like <code>exports</code> fields in <code>package.json</code>.\n</p>\n</div>\n</div>\n<div id=\"outline-container-using-javascript-array-in-clojure\" class=\"outline-3\">\n<a href=\"#using-javascript-array-in-clojure\"><h3 id=\"using-javascript-array-in-clojure\" class=\"cr-self-reference \">Using JavaScript array in Clojure</h3></a>\n<div class=\"outline-text-3\" id=\"text-using-javascript-array-in-clojure\">\n<p>\nIn ClojureScript, many times we can use a JavaScript array just like a ClojureScript vector (not vice versa though).\nWe haven't implement something similar to this.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body><span class=\"hljs-comment\">;; ClojureScript</span>\n(<span class=\"hljs-name\"><span class=\"hljs-built_in\">map</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">fn</span></span> [x] (<span class=\"hljs-name\"><span class=\"hljs-built_in\">*</span></span> x <span class=\"hljs-number\">2</span>)) #js [<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span>])\n<span class=\"hljs-comment\">;; (2 4 6)</span>\n</body></html></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div id=\"outline-container-to-be-continue...\" class=\"outline-2\">\n<a href=\"#to-be-continue...\"><h2 id=\"to-be-continue...\" class=\"cr-self-reference \">To Be Continue…</h2></a>\n<div class=\"outline-text-2\" id=\"text-to-be-continue...\">\n<p>\nDespite the limitations, I still believe this approach is something worth exploring. I'm planning on making an isomorphic React demonstration with Server Side Rendering and Client Side Rehydration using only a thin wrapper over React and React DOM Server (instead of reimplementing the SSR logics on the JVM). The code presented here is also expanded and refined when I'm writing the blog, and the code is open sourced at <a href=\"https://github.com/imakira/js4clj\">imakira/js4clj</a>.\n</p>\n</div>\n</div>\n","blog/orgx-require":null,"blog/modified-date":"2025-11-18T15:03:31+08:00"};
globalThis["net-coruscation-cerulean-common-pages-225-15experiment-with-graalvm--clojure--and-javascript"] = "[{:level 1, :content \"Basic Setup and a Hello World Program\", :id \"basic-setup-and-a-hello-world-program\"} {:level 1, :content \"Working With JavaScript Libraries\", :id \"working-with-javascript-libraries\"} {:level 1, :content \"Ease Things With Helper Functions, Macros and More\", :id \"ease-things-with-helper-functions,-macros-and-more\"} {:level 2, :content \"Mapping between Clojure and Polyglot Values\", :id \"mapping-between-clojure-and-polyglot-values\"} {:level 3, :content \"Primitive Types\", :id \"primitive-types\"} {:level 3, :content \"Functions\", :id \"functions\"} {:level 3, :content \"Objects\", :id \"mapping_objects\"} {:level 2, :content \"Dot Macros and  set!\", :id \"dot-macros-and-~set!~\"} {:level 2, :content \"require  command\", :id \"~require~-command\"} {:level 2, :content \"Bonus: Special  js  namespace\", :id \"bonus:-special-~js~-namespace\"} {:level 1, :content \"Limitations\", :id \"limitations\"} {:level 2, :content \"Functionalities specific to an environment\", :id \"functionalities-specific-to-an-environment\"} {:level 2, :content \"Multithreading and the  js  namespace\", :id \"multithreading-and-the-~js~-namespace\"} {:level 2, :content \"Shorthands for dot macros\", :id \"shorthands-for-dot-macros\"} {:level 2, :content \"Importing ECMAScript Modules\", :id \"importing-ecmascript-modules\"} {:level 2, :content \"Using JavaScript array in Clojure\", :id \"using-javascript-array-in-clojure\"} {:level 1, :content \"To Be Continue…\", :id \"to-be-continue...\"}]\n";</script><script defer="defer" src="/js/main.js" type="module"></script></body></html>