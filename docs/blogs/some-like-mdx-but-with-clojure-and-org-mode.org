#+title: Something Like MDX but with Clojure and Org-Mode for My Personal Blog: Part I
#+CATEGORY: Coding
#+ORGX: true
#+ORGX_REQUIRE: [[clojure.pprint :as pprint]]

[[https://mdxjs.com/][MDX]] is a tool lets you write JavaScript and JSX in a Markdown file. It will then compile the Markdown file into a JavaScript file, so that we can use it from other JavaScript code. I always wanted something similar for my personal blog. For some background, the blogging program is written in Clojure/ClojureScript. The blogging program runs on the JVM, it works by statically generating all the HTML and other files so that the result could be hosted on platforms like Github Pages. Posts of my blog are written in [[https://orgmode.org][org-mode]]. As the blog program runs on the JVM, directly using MDX is theoratically possible, but probably would create a lot of frictions.

Therefore I took some time to implement something similar. Albeit it is not fully tested, the result is quite satisfactory: I can embed Clojure code directly in an Org file, or use React components defined in Clojure code with native Org syntax. The Org file can then be converted into a Cljc file and used from other Clojure code.

In the following sections I will call it ~OrgX~.

#+begin_orgx_info
/This is part *one* of the series, in this post I will show the features and in the next post I will describe the process of implementing it/
#+end_orgx_info

* How OrgX Works

Similar to MDX, OrgX works by compiling the OrgX file into a [[https://clojure.org/guides/reader_conditionals][Cljc]] file. A basic OrgX file would look like this:

#+attr_orgx_defui: true
#+begin_orgx_orgx-example
#+begin_example
  ,#+ORGX: true

  /*Hello* from @@orgx:($ :span "OrgX")@@/

  ,#+begin_orgx
  ($ :div (str "Hello" " World!"))
  ,#+end_orgx
#+end_example
#+end_orgx_orgx-example


#+begin_orgx
($ tabs {:tab-list [{:name "example.org" :content ($ orgx-example)}]})
#+end_orgx


It will be converted into something similar to the following Clojure snippet.

#+attr_orgx_defui: true
#+begin_orgx_orgx-cljc
#+begin_src clojure
  (ns orgx.example
    (:require [uix.core :as uix :refer
               [defui use-state use-effect use-context $]]))

  (defui _comp [post-props]
    ($ :<>
       ($ :p {} ($ :i {}
                   ($ :b {} "Hello")
                   " from "
                   ($ :span "OrgX")))
       ($ :div (str "Hello" " World!"))))

  (defui component [props]
    ($ _comp (merge (quote {#_"default properties"}) props)))
#+end_src
#+end_orgx_orgx-cljc

#+begin_orgx
($ tabs {:tab-list [{:name "orgx/example.cljc" :content ($ orgx-cljc)}]})
#+end_orgx

#+begin_orgx_note
The blogging program uses [[https://github.com/pitch-io/uix?tab=readme-ov-file][uix]] as its React wrapper, thus the generated Clojure code is using uix. Some uix functions like ~$~ are also imported by default. 
#+end_orgx_note

As you can see from this example:

+ We can =@@orgx:@@= for inline Clojure code and =#+begin_orgx= for Clojure blocks.
+ The embedded Clojure code are put in a component called ~_comp~, along with other contents in the Org file.
+ The outer ~component~ wraps the ~_comp~ component, its provides some metadata about this post related to the blogging program. More about this on the following sections.
+ We can use the ~component~ component from other Clojure code.
  
* Basic Usage

As we have seen from the earily example, ~#+begin_orgx~ and ~@@orgx:@@~ are the most basic structure for standalone and inline Clojure code, respectively.

We can have a clickable button with the following code.

#+begin_example
  ,#+begin_orgx
    ;; you can style it using tailwindcss
    ($ :button {:class "bg-sky-600 text-neutral-50 py-1 px-2 rounded-lg"
       :on-click (fn [& _]
                     #?(:cljs (js/alert "clicked!")))}
    "click me")
  ,#+end_orgx
#+end_example

That will be rendered as:

#+begin_orgx
  ($ :button {:class "my-2 bg-sky-600 text-neutral-50 py-1 px-2 rounded-lg" :on-click (fn [& _] #?(:cljs (js/alert "clicked!")))} "Click Me")
#+end_orgx

Notice the [[https://clojure.org/guides/reader_conditionals][reader conditional macro]] ~#?(:cljs)~  . The generated Clojure code is in a Cljc file, therefore it pairs well with the server side rendering or static generation. However, it also means we need to put the platform specified code in the corresponding reader conditionals.

#+begin_example
  We can also use the button inline this way: @@orgx:($ :button {:class "bg-sky-600 text-neutral-50 py-1 px-2 rounded-lg" :on-click (fn [& _] #?(:cljs (js/alert "clicked!")))} "Click Me")@@
#+end_example

The above snippet will be rendered as:

We can also use the button inline this way: @@orgx:($ :button {:class "bg-sky-600 text-neutral-50 py-1 px-2 rounded-lg" :on-click (fn [& _] #?(:cljs (js/alert "clicked!")))} "Click Me")@@

** Toplevel Clojure Code

You may have noticed that, all the Clojure code being put in a component means that we can't use Clojure code that only works on the top level like ~defn~ or ~require~. To solve this, we can use ~#+attr_orgx_toplevel: true~ to mark a OrgX block and make its contents appear in toplevel of the generated Clojure file.

Let's go back to the button example, we can define a ~my-button~ component with the following code:

#+begin_example
  ,#+attr_orgx_toplevel: true
  ,#+begin_orgx
  (defui my-button [{:keys [children callback]}]
      ($ :button {:class "bg-sky-600 text-neutral-50 py-1 px-2 rounded-lg"
         :on-click (fn [& _]
                     (if callback (callback)))}
      children))
  ,#+end_orgx
#+end_example

#+attr_orgx_toplevel: true
#+begin_orgx
  (defui my-button [{:keys [children callback]}]
      ($ :button {:class "bg-sky-600 text-neutral-50 py-1 px-2 rounded-lg"
         :on-click (fn [& _]
                     (if callback (callback)))}
      children))
#+end_orgx

The ~defui~ will be put on the top level in the generated Clojure code, along side something like ~_comp~:

#+begin_src clojure
  (ns ...)
  (defui my-button [{:keys [children callback]}]
    ($ :button {:class "bg-sky-600 text-neutral-50 py-1 px-2 rounded-lg"
                :on-click (fn [& _]
                            #?(:cljs (callback)))}
       children))

  (defui _comp ...)
#+end_src

We can then easily use the ~my-button~ component with either inline or standalone OrgX block.

#+attr_orgx_defui: true
#+begin_orgx_mybutton_example
#+begin_example
Inline OrgX block:
@@orgx:($ my-button {:callback (fn [] #?(:cljs (js/alert "Hello From inline OrgX")))} "From inline OrgX")@@
#+begin_orgx
($ :div "We can also use it in a orgx block"
    ($ my-button {:callback (fn [] #?(:cljs (js/alert "Hello from OrgX block!")))}
         "From OrgX block"))
#+end_orgx
#+end_example
#+end_orgx_mybutton_example

#+attr_orgx_defui: true
#+begin_orgx_mybutton_result
Inline OrgX block:
@@orgx:($ my-button {:callback (fn [] #?(:cljs (js/alert "Hello From inline OrgX")))} "From inline OrgX")@@
#+begin_orgx
($ :div "We can also use it in a orgx block"
    ($ my-button {:callback (fn [] #?(:cljs (js/alert "Hello from OrgX block!")))}
         "From OrgX block"))
#+end_orgx
#+end_orgx_mybutton_result

#+begin_orgx
($ showcase {:showcase-name "Rendering"}
  ($ tabs {:tab-list [{:name "Example Usage" :content ($ mybutton_example)}]})
  ($ mybutton_result))
#+end_orgx

** Import Modules
:PROPERTIES:
:CUSTOM_ID: import-modules
:END:

In MDX, we can import modules with normal ~import~ statements. In OrgX, we can do something similar with toplevel OrgX block and the ~require~ function.

#+begin_example
  ,#+attr_orgx_toplevel: true
  ,#+begin_orgx
  (require '[clojure.string :as string])
  ,#+end_orgx
#+end_example

We can also do this with keyword metadata at the beginning of an Org file.

#+begin_example
  ,#+ORGX_REQUIRE: [[clojure.string :as string]]
#+end_example

#+begin_orgx_note
Settings in keyword metadata currently doesn't support reader macros.
#+end_orgx_note

** Access Component Properties

Similar to MDX, we can access the component's properties with the ~post-props~ variable. Some metadata are also provided in the ~post-props~ variable.

#+attr_orgx_defui: true
#+begin_orgx_metadata-example
#+begin_example
  ($ :pre
    (binding [*print-namespace-maps* true]
      (with-out-str (pprint/pprint post-props))))
#+end_example
#+end_orgx_metadata-example

The following metadata are provided by default:

#+begin_orgx
($ showcase ($ tabs {:tab-list [{:name "Example" :content ($ metadata-example)}]}) ($ :pre (binding [*print-namespace-maps* true] (with-out-str (pprint/pprint post-props)))))
#+end_orgx

** Use Other OrgX Files as Components

By default, OrgX files are compiled as Cljc files and will be put in the ~orgx~ namespace. You can import them as described in [[#import-modules][Import Modules]].

* Use OrgX With Native Org Syntax

** Use Components

Writing ~#+begin_orgx~ and Clojure code must be very tedious every time we want to use a simple component, like ~note~ or ~warning~ notice blocks.

To solve this problem, a new syntax ~#+orgx_{comp-name}~ has been introduced.

For example:

#+attr_orgx_defui: true
#+begin_orgx_orgx_syntax_example
#+begin_example
#+begin_orgx_note
This is a note

+ /Normal/ Org markups *can* be used inside it

@@orgx:($ :span "You can even nest OrgX syntax in it")@@
#+end_orgx_note
#+end_example
#+end_orgx_orgx_syntax_example

#+attr_orgx_defui: true
#+begin_orgx_orgx_syntax_result
#+begin_orgx_note
This is a note

+ /Normal/ Org markups *can* be used inside it

@@orgx:($ :span "You can even nest OrgX syntax in it")@@
#+end_orgx_note
#+end_orgx_orgx_syntax_result

#+begin_orgx
($ showcase {:showcase-name "Rendering"}
  ($ tabs {:tab-list [{:name "Use Component With Org Syntax" :content ($  orgx_syntax_example)}]})
  ($ orgx_syntax_result))
#+end_orgx

It works by passing the rendered content to the component ~note~ as ~children~. All other Org markups or structures that can be used in an Org environment can also be used here. You can also nested other OrgX structures in it, except for top level Clojure definition and component building, which are not supported.

#+begin_orgx_note
Currently we can't pass other properties to the component using this syntax, but that might change in the future.
#+end_orgx_note


** Build Components

Something we may want to build a React component out of some Org blocks. Like we may want to pass two Org mode source blocks as arguments to a ~tabs~ components.
To do this, we just need to add an annotation to the existing ~#+begin_orgx_{comp-name}~ syntax:

#+begin_example
#+attr_orgx_defui: true
#+begin_orgx_my-note
*@@orgx:(or (:note-text props) "Tip")@@*
#+begin_orgx
(:children props)
#+end_orgx
#+end_orgx_my-note
#+end_example

#+attr_orgx_defui: true
#+begin_orgx_my-note
*@@orgx:(or (:note-text props) "Tip")@@*
#+begin_orgx
(:children props)
#+end_orgx
#+end_orgx_my-note


As shown in the example, we can use normal Org syntax along with OrgX snippets. We can also access the properties with the ~props~ variable.

In the above example we have defined a ~my-note~ component, we can then use it with any aforementioned methods.

#+attr_orgx_defui: true
#+begin_orgx_my-note-example
#+begin_example
,#+begin_orgx_my-note
This is a note!
,#+end_orgx_my-note
#+end_example
#+end_orgx_my-note-example

#+attr_orgx_defui: true
#+begin_orgx_my-note-result
#+begin_orgx_my-note
This is a note!
#+end_orgx_my-note
#+end_orgx_my-note-result

#+begin_orgx
($ showcase {:showcase-name "Rendering"}
  ($ tabs {:tab-list [{:name "Example Usage" :content ($ my-note-example)}]})
  ($ my-note-result))
#+end_orgx

** Inline OrgX with Macros
#+MACRO: my-button @@orgx:($ my-button {:callback (or $2 nil)} $1)@@

Currently no similar syntax for inline OrgX is supported, however, it is fairly easy to make life easier with macros. Let's go back to use ~my-button~ as the example.

#+attr_orgx_defui: true
#+begin_orgx_macro-example
We can define a macro like:
#+begin_example
#+MACRO: my-button @@orgx:($ my-button {:callback (or $2 nil)} $1)@@
#+end_example


And then use it with:
#+begin_example
{{{my-button("Using Macro", #?(:cljs (fn [] (js/alert "Hello From Macro!"))))}}}
#+end_example
#+end_orgx_macro-example

#+attr_orgx_defui: true
#+begin_orgx_macro-result
{{{my-button("Using Macro", #?(:cljs (fn [] (js/alert "Hello From Macro!"))))}}}
#+end_orgx_macro-result

#+begin_orgx
($ showcase {:showcase-name "Rendering" :class "lg:grid-cols-[minmax(0,1fr)_minmax(0,0.5fr)]"}
  ($ tabs {:tab-list [{:name "Inline OrgX with Macro" :content ($ macro-example)}]})
  ($ macro-result))
#+end_orgx



* Builtin Components

The blogging program provides several builtin components, I will briefly describe their features.

** Simple Notice Blocks
:PROPERTIES:
:CUSTOM_ID: simple-remarks
:END:


It provides most commons blocks like ~info~, ~note~, ~warn~ and ~error~.

#+attr_orgx_defui: true
#+begin_orgx_remarks_example
#+begin_example
#+begin_orgx_info
This is an info
#+end_orgx_info

#+begin_orgx_note
This is a note
#+end_orgx_note

#+begin_orgx_warn
This is a warn
#+end_orgx_warn

#+begin_orgx_error
This is an error
#+end_orgx_error

#+end_example
#+end_orgx_remarks_example

#+attr_orgx_defui: true
#+begin_orgx_remarks_result
#+begin_orgx_info
This is an info
#+end_orgx_info
#+begin_orgx_note
This is a note
#+end_orgx_note
#+begin_orgx_warn
This is a warn
#+end_orgx_warn
#+begin_orgx_error
This is an error
#+end_orgx_error
#+end_orgx_remarks_result

#+begin_orgx
($ showcase {:showcase-name "Rendering"}
  ($ tabs {:tab-list [{:name "Remarks" :content ($ remarks_example)}]})
  ($ remarks_result))
#+end_orgx

** Tabs

#+attr_orgx_defui: true
#+begin_orgx_code_tabs
#+begin_src clojure
  (defui tabs [{:keys [tab-list default-table class]}]
    (let [[selected-tab set-selected-tab!] (use-state (or default-table
                                                          (:name (first tab-list))))]
      ($ :div.my-4.relative.border-sky-300.border-l-2.border-l-neutral-100 {:class class}
         ($ :div.my-0.flex.relative.bg-neutral-100
            (map (fn [{:keys [name]}]
                   ($ :button.font-medium.text-neutral-700.bg-neutral-50.py-1.px-2.border-t-2.border-neutral-50.min-w-28.bg-neutral-50.border-t-neutral-100
                      {:key name
                       :class (when (= name selected-tab)
                                " text-sky-800 border-sky-400 bg-sky-100 border-t-sky-400")
                       :on-click (fn []
                                   #?(:cljs
                                      (set-selected-tab! name)))}
                      name))
                 tab-list))
         ($ :div.my-0.bg-neutral-50.overflow-hidden.px-2.h-full
            (:content (first (filter (fn [{:keys [name]}]
                                       (= name selected-tab))
                                     tab-list)))))))
#+end_src
#+end_orgx_code_tabs

#+attr_orgx_defui: true
#+begin_orgx_tabs_example
#+begin_example
#+begin_orgx
($ tabs {:tab-list [{:name "tabs.clj" :content ($ code_tabs)}
                    {:name "tabs usage" :content ($ tabs_example)}]})
#+end_orgx
#+end_example
#+end_orgx_tabs_example


#+attr_orgx_defui: true
#+begin_orgx_tabs_result
#+begin_orgx
($ tabs {:tab-list [{:name "tabs.clj" :content ($ code_tabs)}
                      {:name "tabs usage" :content ($ tabs_example)}]})
#+end_orgx
#+end_orgx_tabs_result

~tabs~ is like tabs in a browser or a text editor.
#+begin_orgx
($ showcase {:showcase-name "Rendering"}
  ($ tabs {:tab-list [{:name "tabs usage" :content ($ tabs_example)}]})
  ($ tabs_result))
#+end_orgx


** Split Layout

Split layout lets you show two things side by side:

#+begin_example
  ,#+attr_orgx_defui: true
  ,#+begin_orgx_split_1
  ,#+begin_src clojure
    ($ :button {:class "bg-sky-600 text-neutral-50 py-1 px-2 rounded-lg"
                :on-click (fn [& _]
                            #?(:cljs (js/alert "clicked!")))}
       "Click Me")
  ,#+end_src
  ,#+end_orgx_split_1

  ,#+attr_orgx_defui: true
  ,#+begin_orgx_split_2
  ,#+begin_orgx
    ($ :button {:class "bg-sky-600 text-neutral-50 py-1 px-2 rounded-lg"
                :on-click (fn [& _]
                            #?(:cljs (js/alert "clicked!")))}
       "Click Me")
  ,#+end_orgx
  ,#+end_orgx_split_2

  ,#+begin_orgx
  ($ split-layout
  ($ tabs {:tab-list [{:name "button" :content ($ split_1)}]})
  ($ tabs {:tab-list [{:name "showcase" :content ($ split_2)}]}))
  ,#+end_orgx
#+end_example

Will be rendered as:


#+attr_orgx_defui: true
#+begin_orgx_split_1
#+begin_src clojure
  ($ :button {:class "bg-sky-600 text-neutral-50 py-1 px-2 rounded-lg"
              :on-click (fn [& _]
                          #?(:cljs (js/alert "clicked!")))}
     "Click Me")
#+end_src
#+end_orgx_split_1

#+attr_orgx_defui: true
#+begin_orgx_split_2
#+begin_orgx
  ($ :button {:class "bg-sky-600 text-neutral-50 py-1 px-2 rounded-lg"
              :on-click (fn [& _]
                          #?(:cljs (js/alert "clicked!")))}
     "Click Me")
#+end_orgx
#+end_orgx_split_2

#+begin_orgx
($ split-layout
($ tabs {:tab-list [{:name "button" :content ($ split_1)}]})
($ tabs {:tab-list [{:name "showcase" :content ($ split_2)}]}))
#+end_orgx

** Showcase

Showcase is a simple wrapper over ~split-layout~ and ~tabs~. The ~showcase~ component is used extensive in this post, such as the example in [[#simple-remarks][Simple Notice Blocks]] is coded as:

#+begin_example
  ,#+attr_orgx_defui: true
  ,#+begin_orgx_remarks_example
  ,#+begin_example
  ,#+begin_orgx_info
  This is an info
  ,#+end_orgx_info

  ,#+begin_orgx_note
  This is a note
  ,#+end_orgx_note

  ,#+begin_orgx_warn
  This is a warn
  ,#+end_orgx_warn

  ,#+begin_orgx_error
  This is an error
  ,#+end_orgx_error

  ,#+end_example
  ,#+end_orgx_remarks_example

  ,#+attr_orgx_defui: true
  ,#+begin_orgx_remarks_result
  ,#+begin_orgx_info
  This is an info
  ,#+end_orgx_info
  ,#+begin_orgx_note
  This is a note
  ,#+end_orgx_note
  ,#+begin_orgx_warn
  This is a warn
  ,#+end_orgx_warn
  ,#+begin_orgx_error
  This is an error
  ,#+end_orgx_error
  ,#+end_orgx_remarks_result

  ,#+begin_orgx
  ($ showcase {:showcase-name "Rendering"}
    ($ tabs {:tab-list [{:name "Remarks" :content ($ remarks_example)}]})
    ($ remarks_result))
  ,#+end_orgx
#+end_example

* Conclusions

** Caveats

Although I have extensively used it in this demostration and will definitely use it in the future, there are some notably deficiency with the current implementation.

+ You need to read the logging to understand the problem if anything goes wrong. If you want to do SSR or SSG, the fact that the same code must be run on the JVM and the browser and produce the same result adds complexity.
+ The syntax still feels cumbersome in many cases, but that might be improved in the future.
+ The current implementation requires Emacs itself to convert the Org files into HTML, and Clojure code will then process the HTML. The most notably advantage of this method is that we can use the (basically) the full power of Org mode. However, it is also a lot of moving parts.

** Future Plans

I will describe the process of implement it in the next post of this series. Current the code is still coupled with my blogging program. I'm planning on make it a separate library in the future.
