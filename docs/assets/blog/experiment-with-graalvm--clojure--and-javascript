{"description":"A common challenge when making a fullstack website using Clojure/ClojureScript is that, we are often required to use a JavaScript library on the server sid...","category":"Coding","tags":[],"email":null,"content":"<p>\nA common challenge when making a fullstack website using Clojure/ClojureScript is that, we are often required to use a JavaScript library on the server side when doing Server Side Rendering (SSR). GraalVM/GraalJS provides a solution to run JavaScript code on the JVM. If only we could harness that powerâ€¦\n</p>\n\n<p>\nThis blog describes the basic usage of GraalJS and what I managed to achieve with GraalJS and Clojure.\n</p>\n<div id=\"outline-container-basic-setup-and-a-hello-world-program\" class=\"outline-2\">\n<a href=\"#basic-setup-and-a-hello-world-program\"><h2 id=\"basic-setup-and-a-hello-world-program\" class=\"cr-self-reference \">Basic Setup and a Hello World Program</h2></a>\n<div class=\"outline-text-2\" id=\"text-basic-setup-and-a-hello-world-program\">\n<p>\nWe add the following dependencies to our <code>deps.edn</code>\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-bash\"><html><head></head><body>:deps {org.clojure/clojure {:mvn/version <span class=\"hljs-string\">&quot;1.11.1&quot;</span>}\n       org.graalvm.polyglot/polyglot {:mvn/version <span class=\"hljs-string\">&quot;25.0.1&quot;</span>}\n       org.graalvm.js/js-language {:mvn/version <span class=\"hljs-string\">&quot;25.0.1&quot;</span>}\n       org.graalvm.truffle/truffle-runtime {:mvn/version <span class=\"hljs-string\">&quot;25.0.1&quot;</span>}}\n</body></html></code></pre>\n</div>\n\n<p>\nWith the dependencies installed, we can write a Hello World program.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-name\"><span class=\"hljs-built_in\">ns</span></span> your-namespace\n  (<span class=\"hljs-symbol\">:import</span>\n   [org.graalvm.polyglot Context]))\n\n\n(<span class=\"hljs-keyword\">defonce</span> ^<span class=\"hljs-symbol\">:dynamic</span> <span class=\"hljs-title\">*context*</span>\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">-&gt;</span></span> (<span class=\"hljs-name\">Context/newBuilder</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> String [<span class=\"hljs-string\">&quot;js&quot;</span>]))\n      (<span class=\"hljs-name\">.build</span>)))\n\n(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">hello-fn</span> (<span class=\"hljs-name\">.eval</span> *context*\n                     <span class=\"hljs-string\">&quot;js&quot;</span>\n                     <span class=\"hljs-string\">&quot;(function (name) {console.log('hello '+name)})&quot;</span>))\n\n(<span class=\"hljs-name\">.executeVoid</span> hello-fn (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> String [<span class=\"hljs-string\">&quot;world!&quot;</span>])) <span class=\"hljs-comment\">;; output: hello world!</span>\n</body></html></code></pre>\n</div>\n\n<p>\nAll kinds of JavaScript values are represented as <code>org.graalvm.polyglot.Value</code> objects by GraalJS. In the above example the <code>(.eval ...)</code> calling returns a executable <code>polyglot.Value</code>.\n</p>\n\n<p>\nWe can check if it is an executable by calling the <code>.canExecute()</code> method.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-name\">.canExecute</span> hello-fn) <span class=\"hljs-comment\">;; true</span>\n</body></html></code></pre>\n</div>\n\n<p>\nWe can invoke the executable by calling the <code>.execute()</code> method or the <code>.executeVoid()</code> method. Their difference is that latter one doesn't have a return value.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-name\">.executeVoid</span> hello-fn (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> Object [<span class=\"hljs-string\">&quot;world&quot;</span>])) <span class=\"hljs-comment\">;; output: hello world</span>\n\n(<span class=\"hljs-name\">.executeVoid</span> hello-fn (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> Object [<span class=\"hljs-string\">&quot;graaljs&quot;</span>])) <span class=\"hljs-comment\">;; output: hello graaljs</span>\n</body></html></code></pre>\n</div>\n\n<p>\nYou can check if a <code>polyglot.Value</code> object is of a certain type by using methods starting with <code>.is</code>, and convert the <code>Value</code> object to native Java value with methods starting with <code>.as</code>. For example:\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">integer-one</span> (<span class=\"hljs-name\">.eval</span> *context* <span class=\"hljs-string\">&quot;js&quot;</span> <span class=\"hljs-string\">&quot;1&quot;</span>)) <span class=\"hljs-comment\">;; #object[org.graalvm.polyglot.Value 0x3583d830 &quot;1&quot;]</span>\n(<span class=\"hljs-name\">.isNumber</span> integer-one) <span class=\"hljs-comment\">;; true</span>\n(<span class=\"hljs-name\">.asLong</span> integer-one) <span class=\"hljs-comment\">;; 1</span>\n(<span class=\"hljs-name\">.isString</span> integer-one) <span class=\"hljs-comment\">;; false</span>\n(<span class=\"hljs-name\">.asString</span> integer-one) <span class=\"hljs-comment\">;; ERROR: Unhandled java.lang.ClassCastException</span>\n</body></html></code></pre>\n</div>\n\n<p>\nTo handle JavaScript objects, we have <code>.newInstance()</code> for instantiating an Object, <code>.invokeMember()</code> for calling a method, <code>.getMemberKeys()</code>, <code>.getMember()</code> and <code>.putMember()</code> for accessing properties of an object.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body><span class=\"hljs-comment\">;; We can access top-level JavaScript variables using the (.getBindings *context* &quot;js&quot;).</span>\n<span class=\"hljs-comment\">;; It returns a polyglot.Value object from which we can retrieve builtin</span>\n<span class=\"hljs-comment\">;;   JavaScript functions and objects.</span>\n(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">Array</span> (<span class=\"hljs-name\">.getMember</span> (<span class=\"hljs-name\">.getBindings</span> *context* <span class=\"hljs-string\">&quot;js&quot;</span>) <span class=\"hljs-string\">&quot;Array&quot;</span>))\n\n<span class=\"hljs-comment\">;; create an Array</span>\n(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">arr</span> (<span class=\"hljs-name\">.newInstance</span> Array (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> Object [<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span>])))\n\n(<span class=\"hljs-name\">print</span> arr) <span class=\"hljs-comment\">;; #object[org.graalvm.polyglot.Value 0x2dd585ca &quot;(3)[1, 2, 3]&quot;]</span>\n\n<span class=\"hljs-comment\">;; pop a value and cast it to Long</span>\n(<span class=\"hljs-name\">.asLong</span> (<span class=\"hljs-name\">.invokeMember</span> arr <span class=\"hljs-string\">&quot;pop&quot;</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> Object []))) <span class=\"hljs-comment\">;; 3</span>\n\n(<span class=\"hljs-name\">print</span> arr) <span class=\"hljs-comment\">;; #object[org.graalvm.polyglot.Value 0x27e1e162 (2)[1, 2]]</span>\n</body></html></code></pre>\n</div>\n</div>\n</div>\n<div id=\"outline-container-working-with-javascript-libraries\" class=\"outline-2\">\n<a href=\"#working-with-javascript-libraries\"><h2 id=\"working-with-javascript-libraries\" class=\"cr-self-reference \">Working With JavaScript Libraries</h2></a>\n<div class=\"outline-text-2\" id=\"text-working-with-javascript-libraries\">\n<p>\nGraalJS has an option to provide a <code>require</code> function, with which we can import CommonJS JavaScript modules. The option isn't enabled by default. To enable it, we need to change the definition of <code>*context*</code> to the following:\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defonce</span> ^<span class=\"hljs-symbol\">:dynamic</span> <span class=\"hljs-title\">*context*</span>\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">-&gt;</span></span> (<span class=\"hljs-name\">Context/newBuilder</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> String ))\n      (<span class=\"hljs-name\">.allowExperimentalOptions</span> <span class=\"hljs-literal\">true</span>)\n      (<span class=\"hljs-name\">.options</span> (<span class=\"hljs-name\">HashMap.</span>\n                 {<span class=\"hljs-string\">&quot;js.commonjs-require&quot;</span> <span class=\"hljs-string\">&quot;true&quot;</span>\n                  <span class=\"hljs-string\">&quot;js.commonjs-require-cwd&quot;</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> (<span class=\"hljs-name\">System/getProperty</span> <span class=\"hljs-string\">&quot;user.dir&quot;</span>)\n                                                 <span class=\"hljs-string\">&quot;/node_modules&quot;</span>)}))\n      (<span class=\"hljs-name\">.allowIO</span> <span class=\"hljs-literal\">true</span>)\n      (<span class=\"hljs-name\">.build</span>)))\n</body></html></code></pre>\n</div>\n\n<p>\nHere we use as <code>commonjs-require-cwd</code>'s value. It tells GraalJS to find JavaScript modules under the <code>node_modules</code> folder in the project root.\n</p>\n\n<p>\nWe can then install JavaScript libraries using npm under the project root. Here I use &quot;luxon&quot; as an example.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-bash\"><html><head></head><body>npm init\nnpm install luxon\n</body></html></code></pre>\n</div>\n\n<p>\nWe can then import the module by using <code>require</code> function.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">luxon</span> (<span class=\"hljs-name\">.eval</span> *context* <span class=\"hljs-string\">&quot;js&quot;</span> <span class=\"hljs-string\">&quot;require('luxon')&quot;</span>))\n</body></html></code></pre>\n</div>\n\n<p>\nWe can access the resulting module with the <code>.getMember()</code> method.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">DateTime</span> (<span class=\"hljs-name\">.getMember</span> luxon <span class=\"hljs-string\">&quot;DateTime&quot;</span>))\n</body></html></code></pre>\n</div>\n\n<p>\nNow we have the <code>DateTime</code> class from the <code>luxon</code> library, let's try to turn it into something useful:\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defn</span> <span class=\"hljs-title\">now</span> []\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">-&gt;</span></span> DateTime\n      <span class=\"hljs-comment\">;; DateTime.now() returns a DateTime object</span>\n      (<span class=\"hljs-name\">.invokeMember</span> <span class=\"hljs-string\">&quot;now&quot;</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> Object []))\n      <span class=\"hljs-comment\">;; We call the .toString method to convert the object</span>\n      <span class=\"hljs-comment\">;;    into a JavaScript String</span>\n          (<span class=\"hljs-name\">.invokeMember</span> <span class=\"hljs-string\">&quot;toString&quot;</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> Object []))\n      <span class=\"hljs-comment\">;; then we convert the result into a Java String</span>\n          (<span class=\"hljs-name\">.asString</span>)))\n\n<span class=\"hljs-comment\">;; Let's try to call the function</span>\n\n(<span class=\"hljs-name\">now</span>) <span class=\"hljs-comment\">;; &quot;2025-11-15T16:56:49.798+08:00&quot;</span>\n(<span class=\"hljs-name\">now</span>) <span class=\"hljs-comment\">;; &quot;2025-11-15T16:57:01.961+08:00&quot;</span>\n\n</body></html></code></pre>\n</div>\n\n<p>\nWe wrapped the details of interop between Clojure and JavaScript in a Clojure function <code>now</code>. Now if we want to get the current time string from the <code>luxon</code> library, we can just call the <code>now</code> function. The interop is still something quite cumbersome to do, however. In this blog I will show you how to turn it into something way more concise using the macros and other facilities provided by Clojure. Here is a glimpse of it:\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-name\">js..</span> lux/DateTime now toString) <span class=\"hljs-comment\">;; &quot;2025-11-15T17:04:38.574+08:00&quot;</span>\n</body></html></code></pre>\n</div>\n</div>\n</div>\n<div id=\"outline-container-ease-things-with-helper-functions,-macros-and-more\" class=\"outline-2\">\n<a href=\"#ease-things-with-helper-functions,-macros-and-more\"><h2 id=\"ease-things-with-helper-functions,-macros-and-more\" class=\"cr-self-reference \">Ease Things With Helper Functions, Macros and More</h2></a>\n<div class=\"outline-text-2\" id=\"text-ease-things-with-helper-functions,-macros-and-more\">\n<p>\nYou must have noticed the definition of the <code>now</code> function in the previous example is quite clumsy. In ClojureScript we have the following things that can facilitate the interop between ClojureScript and JavaScript\n</p>\n<ul class=\"org-ul\">\n<li>We can require a js module just like a clojure namespace</li>\n<li>A ClojureScript function is just a JavaScript function, we can call JavaScript functions from the ClojureScript side, or we can pass ClojureScript functions to the JavaScript side.</li>\n<li>We have dot macros ( <code>.</code>, <code>..</code> and <code>.-</code> ) and <code>set!</code> to easily access properites or methods of JavaScript objects.</li>\n</ul>\n\n<p>\nTo build something on the same level is probably very hard, however, to build a demonstration of something very similar is indeed very achievable.\n</p>\n</div>\n<div id=\"outline-container-mapping-between-clojure-and-polyglot-values\" class=\"outline-3\">\n<a href=\"#mapping-between-clojure-and-polyglot-values\"><h3 id=\"mapping-between-clojure-and-polyglot-values\" class=\"cr-self-reference \">Mapping between Clojure and Polyglot Values</h3></a>\n<div class=\"outline-text-3\" id=\"text-mapping-between-clojure-and-polyglot-values\">\n<p>\nWe probably don't want to manually convert the result each time we get a value from the JavaScript side as we did in the previous examples. So we would like to put the actual JavaScript functions invoking logics into a wrapper and let the wrapper automatically convert the parameters and the return value for us. To make something like this, and since GraalJS represents each JavaScript value as a Polyglot Value, we first need to establish a mapping between Clojure types and Polyglot Types.\n</p>\n</div>\n<div id=\"outline-container-primitive-types\" class=\"outline-4\">\n<a href=\"#primitive-types\"><h4 id=\"primitive-types\" class=\"cr-self-reference \">Primitive Types</h4></a>\n<div class=\"outline-text-4\" id=\"text-primitive-types\">\n<p>\nEach time we call the <code>.execute()</code> or <code>.invokeMember()</code> method of the <code>polyglot.Value</code> class, GraalJS will convert the arguments using <code>.asValue()</code> method of <code>Context</code> class. However, we are going to wrap Clojure functions as Polyglot functions in the next section. As of now, we write a Clojure -&gt; Polyglot mapping function only calling the <code>.asValue()</code> method.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defn</span> <span class=\"hljs-title\">polyglotalize-clojure</span> [value]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cond</span></span>\n    <span class=\"hljs-comment\">;; https://www.graalvm.org/sdk/javadoc/org/graalvm/polyglot/Context.html#asValue(java.lang.Object)</span>\n    <span class=\"hljs-symbol\">:else</span>\n    (<span class=\"hljs-name\">.asValue</span> *context* value)))\n</body></html></code></pre>\n</div>\n\n<p>\nAs for the mapping from <code>polyglot.Value</code> to Clojure values, we use the various checking and converting methods described before.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defn</span> <span class=\"hljs-title\">clojurify-value</span> [^org.graalvm.polyglot.Value value]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cond</span></span> (<span class=\"hljs-name\">.isHostObject</span> value)\n        (<span class=\"hljs-name\">.asHostObject</span> value)\n\n        (<span class=\"hljs-name\">.isBoolean</span> value)\n        (<span class=\"hljs-name\">.asBoolean</span> value)\n\n        (<span class=\"hljs-name\">.isNull</span> value)\n        <span class=\"hljs-literal\">nil</span>\n\n        (<span class=\"hljs-name\">.isString</span> value)\n        (<span class=\"hljs-name\">.asString</span> value)\n\n        (<span class=\"hljs-name\">.isNumber</span> value)\n        (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cond</span></span> (<span class=\"hljs-name\">.fitsInLong</span> value)\n              (<span class=\"hljs-name\">.asLong</span> value)\n\n              (<span class=\"hljs-name\">.fitsInDouble</span> value)\n              (<span class=\"hljs-name\">.asDouble</span> value))\n\n        <span class=\"hljs-symbol\">:else</span>\n        value))\n</body></html></code></pre>\n</div>\n</div>\n</div>\n<div id=\"outline-container-functions\" class=\"outline-4\">\n<a href=\"#functions\"><h4 id=\"functions\" class=\"cr-self-reference \">Functions</h4></a>\n<div class=\"outline-text-4\" id=\"text-functions\">\n<p>\nGraalVM provides various <code>Proxy</code> objects that we can use to make Clojure objects accessible in the JavaScript environment. To wrap a function, we need to use <code>ProxyExecutable</code>.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defn</span> <span class=\"hljs-title\">wrap-clojure-fn</span> [f]\n  (<span class=\"hljs-name\">.asValue</span> *context*\n            (<span class=\"hljs-name\"><span class=\"hljs-built_in\">with-meta</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">reify</span></span> org.graalvm.polyglot.proxy.ProxyExecutable\n                         #_{<span class=\"hljs-symbol\">:clj-kondo/ignore</span> [<span class=\"hljs-symbol\">:unused-binding</span>]}\n                         <span class=\"hljs-comment\">;; we ignore `this` for now</span>\n                         (<span class=\"hljs-name\">execute</span> [this ^<span class=\"hljs-string\">&quot;[Lorg.graalvm.polyglot.Value;&quot;</span> values]\n                           (<span class=\"hljs-name\">polyglotalize-clojure</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">apply</span></span> f (<span class=\"hljs-name\"><span class=\"hljs-built_in\">map</span></span> clojurify-value values)))))\n              {<span class=\"hljs-symbol\">::raw-fn</span> f})))\n</body></html></code></pre>\n</div>\n\n<p>\nThe function takes a Clojure function as an argument, returns a Polyglot executable that we can pass to the JavaScript environment.\n</p>\n\n<p>\nIn the function body, we use <code>reify</code> to instantiate an object implementing the <code>ProxyExecutable</code> interface. We implement the <code>.execute()</code> method by applying the clojurified arguments to the original Clojure function, and convert the return value back to a Polyglot value using the two functions we wrote in the <a href=\"#primitive-types\">previous section</a>.\n</p>\n\n<p>\nIn case we want to turn the proxy object back into a clojure function (like when a JavaScript function returns the proxy object as is), we save the original Clojure function into the <a href=\"https://clojure.org/reference/metadata\">metadata</a> of the proxy object using <code>with-meta</code>. In the final step, we turn it into a Polyglot Value using <code>.asValue</code> method from <code>Context</code>.\n</p>\n\n<p>\nWrapping functions from JavaScript follows a similar logic.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defn</span> <span class=\"hljs-title\">wrap-polyglot-executable</span> [^org.graalvm.polyglot.Value obj]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">with-meta</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">fn</span></span> [&amp; args]\n               (<span class=\"hljs-name\">clojurify-value</span> (<span class=\"hljs-name\">.execute</span> obj (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> Object (<span class=\"hljs-name\"><span class=\"hljs-built_in\">map</span></span> polyglotalize-clojure args)))))\n    {<span class=\"hljs-symbol\">::raw-value</span> obj}))\n</body></html></code></pre>\n</div>\n\n<p>\nHere, we also save a reference to the original JavaScript function in the metadata. However, it serves a much more important role: In JavaScript, a function is like any object, it can have all kinds of properties. Therefore, after wrapping a JavaScript function as a Clojure function, we may still need to access its other properties. To do this, we save the original function in the metadata and retrieve it if necessary.\n</p>\n\n<p>\nWith these two functions defined, we can then augmented our two mapping functions.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defn</span> <span class=\"hljs-title\">polyglotalize-clojure</span> [value]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cond</span></span> (<span class=\"hljs-symbol\">::raw-value</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">meta</span></span> value))\n        (<span class=\"hljs-symbol\">::raw-value</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">meta</span></span> value))\n\n        (<span class=\"hljs-name\"><span class=\"hljs-built_in\">fn?</span></span> value)\n        (<span class=\"hljs-name\">wrap-clojure-fn</span> value)\n\n        <span class=\"hljs-symbol\">:else</span>\n        <span class=\"hljs-comment\">;; https://www.graalvm.org/sdk/javadoc/org/graalvm/polyglot/Context.html#asValue(java.lang.Object)</span>\n        (<span class=\"hljs-name\">.asValue</span> *context* value)))\n</body></html></code></pre>\n</div>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defn</span> <span class=\"hljs-title\">clojurify-value</span> [^org.graalvm.polyglot.Value value]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">cond</span></span>\n\n    (<span class=\"hljs-name\">.isProxyObject</span> value)\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [prox-obj (<span class=\"hljs-name\">.asProxyObject</span> value)]\n      (<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> (<span class=\"hljs-symbol\">::raw-fn</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">meta</span></span> prox-obj))\n        (<span class=\"hljs-symbol\">::raw-fn</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">meta</span></span> prox-obj))\n        prox-obj))\n\n    <span class=\"hljs-comment\">;;</span>\n    <span class=\"hljs-comment\">;; ... omitted</span>\n    <span class=\"hljs-comment\">;;</span>\n\n    (<span class=\"hljs-name\">.canExecute</span> value) \n    (<span class=\"hljs-name\">wrap-polyglot-executable</span> value)\n\n    <span class=\"hljs-symbol\">:else</span>\n    value))\n</body></html></code></pre>\n</div>\n\n<p>\nWith these two facilities created, we already achieve something very interesting.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">hello</span> (<span class=\"hljs-name\">clojurify-value</span> (<span class=\"hljs-name\">.eval</span> *context* <span class=\"hljs-string\">&quot;js&quot;</span> <span class=\"hljs-string\">&quot;(function (name){console.log(`hello ${name}`)})&quot;</span>)))\n\n(<span class=\"hljs-name\">hello</span> <span class=\"hljs-string\">&quot;world&quot;</span>) <span class=\"hljs-comment\">;; output: hello world</span>\n(<span class=\"hljs-name\">hello</span> <span class=\"hljs-string\">&quot;graaljs&quot;</span>) <span class=\"hljs-comment\">;; output: hello graaljs</span>\n\n(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">to-array</span> (<span class=\"hljs-name\">clojurify-value</span>\n               (<span class=\"hljs-name\">.eval</span> *context* <span class=\"hljs-string\">&quot;js&quot;</span> <span class=\"hljs-string\">&quot;(function (...args){return Array.from(args);})&quot;</span>)))\n\n(<span class=\"hljs-name\"><span class=\"hljs-built_in\">to-array</span></span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\">;; #object[org.graalvm.polyglot.Value 0x26e3da6b &quot;(4)[1, 2, 3, 4]&quot;]</span>\n\n(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">join</span> (<span class=\"hljs-name\">clojurify-value</span>\n           (<span class=\"hljs-name\">.eval</span> *context* <span class=\"hljs-string\">&quot;js&quot;</span> <span class=\"hljs-string\">&quot;(function (s, ...args){return args.join(s);})&quot;</span>)))\n\n(<span class=\"hljs-name\">join</span> <span class=\"hljs-string\">&quot;,&quot;</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\">;; &quot;1,2,3,4&quot;</span>\n</body></html></code></pre>\n</div>\n\n<p>\nAs you have seen, we can now call a JavaScript function just like a Clojure function. Return values of primitive types will also be automatically converted back to Clojure values.\n</p>\n\n<p>\nWe can also pass Clojure functions to the JavaScript side:\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">sum-term</span>\n  (<span class=\"hljs-name\">clojurify-value</span>\n   (<span class=\"hljs-name\">.eval</span> *context* <span class=\"hljs-string\">&quot;js&quot;</span> <span class=\"hljs-string\">&quot;let sum = (term, a, b) =&gt; (a&gt;b)? 0 : term(a) + sum(term, a+1,b); sum&quot;</span>)))\n\n<span class=\"hljs-comment\">;; (sum-integers a b) calculate the sum of integers from `a` to `b` (inclusive)</span>\n(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">sum-integers</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">partial</span></span> sum-term identity))\n(<span class=\"hljs-name\">sum-integers</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">10</span>) <span class=\"hljs-comment\">;; 55</span>\n\n<span class=\"hljs-comment\">;; (sum-cubes a b) calculates the sum of cubes of integers from `a` to `b` (inclusive)</span>\n(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">sum-cubes</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">partial</span></span> sum-term (<span class=\"hljs-name\"><span class=\"hljs-built_in\">fn</span></span> [x] (<span class=\"hljs-name\"><span class=\"hljs-built_in\">*</span></span> x x x))))\n(<span class=\"hljs-name\">sum-cubes</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">10</span>) <span class=\"hljs-comment\">;; 3025</span>\n</body></html></code></pre>\n</div>\n</div>\n</div>\n<div id=\"outline-container-mapping_objects\" class=\"outline-4\">\n<a href=\"#mapping_objects\"><h4 id=\"mapping_objects\" class=\"cr-self-reference \">Objects</h4></a>\n<div class=\"outline-text-4\" id=\"text-mapping_objects\">\n<p>\nRougly similar to ClojureScript, We don't do mapping for objects other than those of primitives types and functions. However, in the <code>clojurify-value</code> function, we wrap all JavaScript functions into Clojure functions and save the reference in the metadata, and as I have explained there, a JavaScript function may have other properties we want to access. Thus, in each place where a Clojure function wrapping a JavaScript function can be taken as arguments, we cannot use methods from <code>polyglot.Value</code>. Instead, we define helper functions that will wrap the arguments if necessary and then call the target method.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defn</span> <span class=\"hljs-title\">polyglot-value</span> [obj]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">or</span></span> (<span class=\"hljs-symbol\">::raw-value</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">meta</span></span> obj))\n      (<span class=\"hljs-name\"><span class=\"hljs-built_in\">and</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">instance?</span></span> org.graalvm.polyglot.Value obj)\n           obj)))\n\n(<span class=\"hljs-keyword\">defn-</span> <span class=\"hljs-title\">to-camel-style</span> [s]\n  (<span class=\"hljs-name\">string/replace</span> s <span class=\"hljs-regex\">#&quot;-([a-z])&quot;</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">fn</span></span> [g]\n                                  (<span class=\"hljs-name\">.toUpperCase</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">second</span></span> g)))))\n\n(<span class=\"hljs-keyword\">defmacro</span> <span class=\"hljs-title\">define-unwrap-executable-alias</span>\n  {<span class=\"hljs-symbol\">:clj-kondo/lint-as</span> 'clojure.core/declare}\n  [name &amp; args]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [docstring? (<span class=\"hljs-name\"><span class=\"hljs-built_in\">string?</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">first</span></span> args))\n        docstring (<span class=\"hljs-name\"><span class=\"hljs-built_in\">when</span></span> docstring? (<span class=\"hljs-name\"><span class=\"hljs-built_in\">first</span></span> args))\n        args (<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> docstring? (<span class=\"hljs-name\"><span class=\"hljs-built_in\">second</span></span> args) (<span class=\"hljs-name\"><span class=\"hljs-built_in\">first</span></span> args))\n        obj 'obj\n        [arglist [_ vararg]] (<span class=\"hljs-name\"><span class=\"hljs-built_in\">split-with</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">fn</span></span> [x] (<span class=\"hljs-name\"><span class=\"hljs-built_in\">not</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">=</span></span> x '&amp;))) args)] \n    `(<span class=\"hljs-keyword\">defn</span> ~<span class=\"hljs-title\">name</span> {<span class=\"hljs-symbol\">:doc</span> ~docstring} [~obj ~@arglist ~@(<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> vararg `[&amp; ~vararg] [])]\n       (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [~obj (<span class=\"hljs-name\"><span class=\"hljs-built_in\">or</span></span> (<span class=\"hljs-name\">polyglot-value</span> ~obj)\n                      ~obj)]\n         (~(<span class=\"hljs-name\"><span class=\"hljs-built_in\">symbol</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> <span class=\"hljs-string\">&quot;.&quot;</span> (<span class=\"hljs-name\">to-camel-style</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> name))))\n          ~obj \n          ~@arglist\n          ~@(<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> vararg\n              [`(<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> Object ~vararg)]\n              []))))))\n\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> get-meta-object)\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> is-meta-object)\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> get-meta-qualified-name)\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> has-meta-parents)\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> has-array-elements)\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> get-meta-parents)\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> get-member [^String identifier])\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> put-member [^String identifier ^Object value])\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> get-member-keys)\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> new-instance [&amp; args])\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> can-invoke-member [^String s])\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> invoke-member [^String method &amp; args])\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> can-instantiate)\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> canExecute)\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> execute [&amp; args])\n(<span class=\"hljs-name\">define-unwrap-executable-alias</span> executeVoid [&amp; args])\n</body></html></code></pre>\n</div>\n\n<p>\nWe wrote a macro for this purpose. The macro takes a function name and a parameter list as arguments and defines a function with the name and parameters.\nThe function defined by the macro retrieves the reference from the metadata if necessary, then calls a method by the name converted from the function name and with arguments from the parameter list.\n</p>\n\n<p>\nOne nice bonus is that the generated functions assembles all the variadic arguments into an <code>Object[]</code>, saving us from calling <code>(into-arry Object)</code> manually if we need to call a method with variadic arguments.\n</p>\n\n<p>\nPreviously we need to do this:\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-name\">.newInstance</span> (<span class=\"hljs-name\">.eval</span> *context* <span class=\"hljs-string\">&quot;js&quot;</span> <span class=\"hljs-string\">&quot;Array&quot;</span>) (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> Object [<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span>]))\n<span class=\"hljs-comment\">;; #object[org.graalvm.polyglot.Value 0x65b337ef &quot;(3)[1, 2, 3]&quot;]</span>\n</body></html></code></pre>\n</div>\n\n<p>\nNow we just need to do this:\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-name\">new-instance</span> (<span class=\"hljs-name\">.eval</span> *context* <span class=\"hljs-string\">&quot;js&quot;</span> <span class=\"hljs-string\">&quot;Array&quot;</span>) <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span>)\n<span class=\"hljs-comment\">;; #object[org.graalvm.polyglot.Value 0xfdabe76 &quot;(3)[1, 2, 3]&quot;]</span>\n</body></html></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div id=\"outline-container-dot-macros-and-~set!~\" class=\"outline-3\">\n<a href=\"#dot-macros-and-~set!~\"><h3 id=\"dot-macros-and-~set!~\" class=\"cr-self-reference \">Dot Macros and <code>set!</code></h3></a>\n<div class=\"outline-text-3\" id=\"text-dot-macros-and-~set!~\">\n<p>\nIn ClojureScript we have dots special forms or macros like <code>.</code>,  <code>.-</code> and <code>..</code> for accessing properties or calling methods of JavaScript objects.\n</p>\n\n<p>\nWe can relatively easily implement them using macros.\n</p>\n\n<blockquote>\n<p>\nThere are also <code>(.method obj)</code> <code>(.-property obj)</code> as shorthands for <code>(. obj method)</code> and <code>(.- obj property)</code> in ClojureScript. However, implementing them would be really difficult if not impossible.\n</p>\n</blockquote>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defmacro</span> <span class=\"hljs-title\">js.</span>\n  {<span class=\"hljs-symbol\">:clj-kondo/ignore</span> [<span class=\"hljs-symbol\">:unresolved-symbol</span> <span class=\"hljs-symbol\">:type-mismatch</span>]}\n  [obj method &amp; args]\n  `(<span class=\"hljs-name\">clojurify-value</span>\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">apply</span></span> invoke-member ~obj ~(<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> method)\n           <span class=\"hljs-comment\">;; evaluate args before passing them to polyglotalize-clojure</span>\n           (<span class=\"hljs-name\"><span class=\"hljs-built_in\">map</span></span> polyglotalize-clojure (<span class=\"hljs-name\"><span class=\"hljs-built_in\">list</span></span> ~@args)))))\n\n\n(<span class=\"hljs-keyword\">defmacro</span> <span class=\"hljs-title\">js.-</span>\n  {<span class=\"hljs-symbol\">:clj-kondo/ignore</span> [<span class=\"hljs-symbol\">:unresolved-symbol</span> <span class=\"hljs-symbol\">:type-mismatch</span>]}\n  [obj field]\n  `(<span class=\"hljs-name\">#'clojurify-value</span> (<span class=\"hljs-name\">get-member</span> ~obj ~(<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> field))))\n</body></html></code></pre>\n</div>\n\n<p>\nThe <code>invoke-member</code> and <code>get-member</code> helper functions are defined in the <a href=\"#mapping_objects\">previous section</a>.\n</p>\n\n<p>\nWith these two defined, we can write the more complicated macro <code>js..</code> based on them.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defmacro</span> <span class=\"hljs-title\">js..</span>\n  {<span class=\"hljs-symbol\">:clj-kondo/ignore</span> [<span class=\"hljs-symbol\">:unresolved-symbol</span> <span class=\"hljs-symbol\">:type-mismatch</span>]}\n  [obj &amp; args]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">empty?</span></span> args)\n    obj\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [curr# (<span class=\"hljs-name\"><span class=\"hljs-built_in\">first</span></span> args)\n          rest# (<span class=\"hljs-name\"><span class=\"hljs-built_in\">rest</span></span> args)]\n      `(<span class=\"hljs-name\">js..</span> ~(<span class=\"hljs-name\"><span class=\"hljs-built_in\">cond</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">seq?</span></span> curr#)\n                    `(<span class=\"hljs-name\">js.</span> ~obj ~(<span class=\"hljs-name\"><span class=\"hljs-built_in\">first</span></span> curr#) ~@(<span class=\"hljs-name\"><span class=\"hljs-built_in\">rest</span></span> curr#))\n\n                    (<span class=\"hljs-name\">.startsWith</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> curr#)\n                                 <span class=\"hljs-string\">&quot;-&quot;</span>)\n                    `(<span class=\"hljs-name\">js.-</span> ~obj ~(<span class=\"hljs-name\">subs</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> curr#) <span class=\"hljs-number\">1</span>))\n\n                    <span class=\"hljs-symbol\">:else</span>\n                    `(<span class=\"hljs-name\">js.</span> ~obj ~curr#))\n         ~@rest#))))\n</body></html></code></pre>\n</div>\n\n<p>\nFinally, we will implement the <code>set!</code> macro.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defmacro</span> <span class=\"hljs-title\">js-set!</span> [dot-form value]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">assert</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">seq?</span></span> dot-form) <span class=\"hljs-string\">&quot;First argument must be in the form of `(js.. obj -field)` or (js.- obj field)&quot;</span>)\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [[op &amp; args] dot-form]\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">assert</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">or</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">=</span></span> op 'js..)\n                (<span class=\"hljs-name\"><span class=\"hljs-built_in\">=</span></span> op 'js.-))\n            <span class=\"hljs-string\">&quot;First argument to js-set! must start with either `js..` or `js.-`&quot;</span>)\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [remove-hyphen (<span class=\"hljs-name\"><span class=\"hljs-built_in\">=</span></span> op 'js..)\n          lst (<span class=\"hljs-name\"><span class=\"hljs-built_in\">last</span></span> args)\n          last-removed (<span class=\"hljs-name\"><span class=\"hljs-built_in\">drop-last</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into</span></span> [op] args))]\n      `(<span class=\"hljs-name\">put-member</span> ~(<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">=</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">count</span></span> last-removed) <span class=\"hljs-number\">2</span>)\n                      (<span class=\"hljs-name\"><span class=\"hljs-built_in\">second</span></span> last-removed)\n                      last-removed)\n                   ~(<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> remove-hyphen\n                      (<span class=\"hljs-name\">subs</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> lst) <span class=\"hljs-number\">1</span>)\n                      (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> lst))\n                   ~value))))\n</body></html></code></pre>\n</div>\n\n<p>\nLet's go back to the <code>luxon</code> example mentioned in the beginning of this blog and check what we can do with these newly defined tools.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">luxon</span> (<span class=\"hljs-name\">.eval</span> *context* <span class=\"hljs-string\">&quot;js&quot;</span> <span class=\"hljs-string\">&quot;require('luxon')&quot;</span>))\n\n(<span class=\"hljs-name\">js..</span> luxon -DateTime now toString) <span class=\"hljs-comment\">;; &quot;2025-11-14T16:48:11.324+08:00&quot;</span>\n</body></html></code></pre>\n</div>\n\n<p>\nCompare it to the snippet I showed at the end of the first section:\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-name\">js..</span> lux/DateTime now toString)\n</body></html></code></pre>\n</div>\n\n<p>\nThe only thing lacking is a <code>require</code> mechanism, which is what we are going to implement in the next section.\n</p>\n</div>\n</div>\n<div id=\"outline-container-~require~-command\" class=\"outline-3\">\n<a href=\"#~require~-command\"><h3 id=\"~require~-command\" class=\"cr-self-reference \"><code>require</code> command</h3></a>\n<div class=\"outline-text-3\" id=\"text-~require~-command\">\n<p>\nOn the JavaScript side, the <code>require()</code> function returns an object from which we can access its exported variables or functions.\n</p>\n\n<p>\nOn the Clojure side, we can dynamically create a namespace with the <code>create-ns</code> function. After that we can make all the variables from the module object accessible in the newly created namespace with the <code>intern</code> function.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defn-</span> <span class=\"hljs-title\">require-module</span> [name]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">-&gt;</span></span> *context*\n      (<span class=\"hljs-name\">.eval</span> <span class=\"hljs-string\">&quot;js&quot;</span>\n             (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> <span class=\"hljs-string\">&quot;require('&quot;</span> name <span class=\"hljs-string\">&quot;')&quot;</span>))))\n\n(<span class=\"hljs-keyword\">defn-</span> <span class=\"hljs-title\">parse-flags</span> [args]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">loop</span></span> [args (<span class=\"hljs-name\"><span class=\"hljs-built_in\">lazy-seq</span></span> args)\n         result (<span class=\"hljs-name\"><span class=\"hljs-built_in\">hash-map</span></span>)]\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">empty?</span></span> args)\n      result\n      (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [curr (<span class=\"hljs-name\"><span class=\"hljs-built_in\">first</span></span> args)\n            rst (<span class=\"hljs-name\"><span class=\"hljs-built_in\">rest</span></span> args)]\n        (<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">or</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">keyword?</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">first</span></span> rst))\n                (<span class=\"hljs-name\"><span class=\"hljs-built_in\">empty?</span></span> rst))\n          (<span class=\"hljs-name\"><span class=\"hljs-built_in\">recur</span></span> rst (<span class=\"hljs-name\"><span class=\"hljs-built_in\">assoc</span></span> result curr <span class=\"hljs-literal\">true</span>))\n          (<span class=\"hljs-name\"><span class=\"hljs-built_in\">recur</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">rest</span></span> rst)\n                 (<span class=\"hljs-name\"><span class=\"hljs-built_in\">assoc</span></span> result curr (<span class=\"hljs-name\"><span class=\"hljs-built_in\">first</span></span> rst))))))))\n\n(<span class=\"hljs-keyword\">defn-</span> <span class=\"hljs-title\">normalize-module-name</span> [name]\n  (<span class=\"hljs-name\">s/replace</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> name) <span class=\"hljs-regex\">#&quot;/&quot;</span> <span class=\"hljs-string\">&quot;.&quot;</span>))\n\n(<span class=\"hljs-keyword\">defn</span> <span class=\"hljs-title\">require-js</span>\n  {<span class=\"hljs-symbol\">:clj-kondo/lint-as</span> 'clojure.core/require}\n  [[module-name &amp; flags] &amp; coll]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [flag-map (<span class=\"hljs-name\">parse-flags</span> flags)\n        module (<span class=\"hljs-name\">require-module</span> module-name)\n        alias-name (<span class=\"hljs-symbol\">:as</span> flag-map)\n        qualified-module-name (<span class=\"hljs-name\"><span class=\"hljs-built_in\">symbol</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> <span class=\"hljs-string\">&quot;js4clj.modules.&quot;</span> (<span class=\"hljs-name\">normalize-module-name</span> module-name)))]\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">create-ns</span></span> qualified-module-name)\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">doseq</span></span> [k (<span class=\"hljs-name\">.getMemberKeys</span> module)]\n      (<span class=\"hljs-name\"><span class=\"hljs-built_in\">intern</span></span> qualified-module-name\n              (<span class=\"hljs-name\"><span class=\"hljs-built_in\">symbol</span></span> k)\n              (<span class=\"hljs-name\">clojurify-value</span> (<span class=\"hljs-name\">.getMember</span> module k))))\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">when</span></span> alias-name\n      (<span class=\"hljs-name\"><span class=\"hljs-built_in\">alias</span></span> alias-name qualified-module-name)))\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">when</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">seq</span></span> coll)\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">apply</span></span> require-js coll)))\n</body></html></code></pre>\n</div>\n\n<p>\n<code>(require-js '[luxon :as lux])</code> is now all we need to require a JavaScript module.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-name\">require-js</span> '[luxon <span class=\"hljs-symbol\">:as</span> lux])\n\n(<span class=\"hljs-name\">js..</span> lux/DateTime now toString) <span class=\"hljs-comment\">;; &quot;2025-11-14T17:08:40.045+08:00&quot;</span>\n</body></html></code></pre>\n</div>\n\n<p>\nLet's try some more examples:\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-name\">js..</span> lux/DateTime (<span class=\"hljs-name\">fromISO</span> <span class=\"hljs-string\">&quot;2017-05-15T08:30:00&quot;</span>) -year) <span class=\"hljs-comment\">;; 2017</span>\n\n<span class=\"hljs-comment\">;; or write it as</span>\n(<span class=\"hljs-name\"><span class=\"hljs-built_in\">-&gt;</span></span> lux/DateTime\n    (<span class=\"hljs-name\">js.</span> fromISO <span class=\"hljs-string\">&quot;2017-05-15T08:30:00&quot;</span>)\n    (<span class=\"hljs-name\">js.-</span> year)) <span class=\"hljs-comment\">;; 2017</span>\n\n(<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [now (<span class=\"hljs-name\">js.</span> lux/DateTime now)\n      later (<span class=\"hljs-name\">js.</span> lux/DateTime local <span class=\"hljs-number\">2026</span> <span class=\"hljs-number\">10</span> <span class=\"hljs-number\">12</span>)\n      i (<span class=\"hljs-name\">js.</span> lux/Interval fromDateTimes now later)]\n  (<span class=\"hljs-name\">js.</span> i length <span class=\"hljs-string\">&quot;years&quot;</span>)) <span class=\"hljs-comment\">;; 0.904136850298072</span>\n</body></html></code></pre>\n</div>\n</div>\n</div>\n<div id=\"outline-container-bonus:-special-~js~-namespace\" class=\"outline-3\">\n<a href=\"#bonus:-special-~js~-namespace\"><h3 id=\"bonus:-special-~js~-namespace\" class=\"cr-self-reference \">Bonus: Special <code>js</code> namespace</h3></a>\n<div class=\"outline-text-3\" id=\"text-bonus:-special-~js~-namespace\">\n<p>\nClojureScript provides us a <a href=\"https://cljs.github.io/api/syntax/js-namespace\">special <code>js</code> namespace</a>, from where we can use various JavaScript global objects. We can also implement something like that.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">def</span> ^<span class=\"hljs-symbol\">:dynamic</span> <span class=\"hljs-title\">*no-clojurify*</span> <span class=\"hljs-literal\">false</span>)\n\n(<span class=\"hljs-keyword\">defn-</span> <span class=\"hljs-title\">define-builtin</span> [ns primitive &amp; [alias]]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">intern</span></span> ns (<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> alias (<span class=\"hljs-name\"><span class=\"hljs-built_in\">symbol</span></span> alias) (<span class=\"hljs-name\"><span class=\"hljs-built_in\">symbol</span></span> primitive))\n          ((<span class=\"hljs-name\"><span class=\"hljs-built_in\">if</span></span> *no-clojurify* identity clojurify-value)\n           (<span class=\"hljs-name\">.eval</span> *context* <span class=\"hljs-string\">&quot;js&quot;</span> primitive))))\n\n(<span class=\"hljs-keyword\">defmacro</span> <span class=\"hljs-title\">define-builtins</span>\n  {<span class=\"hljs-symbol\">:clj-kondo/lint-as</span> 'clojure.core/declare}\n  [ns &amp; primitives]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">create-ns</span></span> ns)\n  `(<span class=\"hljs-name\"><span class=\"hljs-built_in\">doseq</span></span> [primitive# '~primitives]\n     (<span class=\"hljs-name\">define-builtin</span> '~ns (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> primitive#))))\n\n<span class=\"hljs-comment\">;; In cljs there is also a js/undefined</span>\n<span class=\"hljs-comment\">;;\tin which (= nil js/undefined) but we can't mimic it.</span>\n<span class=\"hljs-comment\">;; Still, we need a js/undefined in case we need to do some</span>\n<span class=\"hljs-comment\">;; \tvery specific interop.</span>\n(<span class=\"hljs-name\"><span class=\"hljs-built_in\">declare</span></span> undefined)\n(<span class=\"hljs-name\">with-bindings</span> {#'*no-clojurify* <span class=\"hljs-literal\">true</span>}\n  (<span class=\"hljs-name\">define-builtin</span> 'js <span class=\"hljs-string\">&quot;undefined&quot;</span> <span class=\"hljs-string\">&quot;undefined&quot;</span>))\n\n#_{<span class=\"hljs-symbol\">:clojure-lsp/ignore</span> [<span class=\"hljs-symbol\">:clojure-lsp/unused-public-var</span>]}\n(<span class=\"hljs-name\">define-builtins</span> js\n  globalThis\n  Infinity\n  NaN\n  Object\n  Function\n  Boolean\n  Symbol\n  Error\n  Number\n  BigInt\n  Math\n  Date\n  String\n  Array\n  Map\n  Set\n  WeakMap\n  WeakSet\n  JSON\n  ArrayBuffer\n  Promise\n  console)\n</body></html></code></pre>\n</div>\n\n<p>\nWe took a special handling of <code>js/undefined</code> (note when we clojurify JavaScript values, we turn both <code>null</code> and <code>undefined</code> into <code>nil</code>), since a direct equivalent of <code>undefined</code> in JavaScript may be needed for some interops. However, <code>js/undefined</code> In ClojureScript has some special properties we can't replicate, most notably, <code>(nil? js/undefined)</code> and <code>(= js/undefined nil)</code> results in <code>true</code> in ClojureScript.\n</p>\n</div>\n</div>\n</div>\n<div id=\"outline-container-limitations\" class=\"outline-2\">\n<a href=\"#limitations\"><h2 id=\"limitations\" class=\"cr-self-reference \">Limitations</h2></a>\n<div class=\"outline-text-2\" id=\"text-limitations\">\n</div>\n<div id=\"outline-container-functionalities-specific-to-an-environment\" class=\"outline-3\">\n<a href=\"#functionalities-specific-to-an-environment\"><h3 id=\"functionalities-specific-to-an-environment\" class=\"cr-self-reference \">Functionalities specific to an environment</h3></a>\n<div class=\"outline-text-3\" id=\"text-functionalities-specific-to-an-environment\">\n<p>\nJavaScript packages are often written under the assumption that, the code will either run on a Browser or a node.js environment. Unfortunately, GraalJS only implements the ECMAScript specification, which means we have neither functions specific to node.js nor functions specific to a browser.\n</p>\n\n<p>\nFor example, we don't have <code>WebWorker</code> api from the browser, nor <code>process</code>, <code>fs</code> api from node.js.\n</p>\n</div>\n</div>\n<div id=\"outline-container-multithreading-and-the-~js~-namespace\" class=\"outline-3\">\n<a href=\"#multithreading-and-the-~js~-namespace\"><h3 id=\"multithreading-and-the-~js~-namespace\" class=\"cr-self-reference \">Multithreading and the <code>js</code> namespace</h3></a>\n<div class=\"outline-text-3\" id=\"text-multithreading-and-the-~js~-namespace\">\n<p>\nWhen writing programs in Java, we usually use blocking operations and multithreading. However, <code>polyglot.Context</code> is not thread-safe. It isn't a problem in itself, since we can spin up multiple contexts. However, variables in <code>js</code> refer to variables in a specific context. Thus, if we want to use multiple contexts, we cannot refer to variables in the <code>js</code> namespace with the current settings. We may be able to mitigate or solve this problem with dynamic bindings or using a dedicated thread for JavaScript operations.\n</p>\n</div>\n</div>\n<div id=\"outline-container-shorthands-for-dot-macros\" class=\"outline-3\">\n<a href=\"#shorthands-for-dot-macros\"><h3 id=\"shorthands-for-dot-macros\" class=\"cr-self-reference \">Shorthands for dot macros</h3></a>\n<div class=\"outline-text-3\" id=\"text-shorthands-for-dot-macros\">\n<p>\nWe have already talked about it in the <a href=\"#dot-macros-and-~set!~\">Dot Macros</a> section. In ClojureScript we can <code>(ClassName.)</code> for instantiate an instance or <code>(.method obj)</code> for invoking an method. Implementing them would be really hard if not impossible.\n</p>\n</div>\n</div>\n<div id=\"outline-container-importing-ecmascript-modules\" class=\"outline-3\">\n<a href=\"#importing-ecmascript-modules\"><h3 id=\"importing-ecmascript-modules\" class=\"cr-self-reference \">Importing ECMAScript Modules</h3></a>\n<div class=\"outline-text-3\" id=\"text-importing-ecmascript-modules\">\n<p>\nThe <code>require-js</code> function can only import CommonJS modules. More and more projects are choosing ECMAScript modules over CommonJS modules these days. However, implementing an importing mechanism for ECMAScript modules is entirely feasible. GraalJS provides a <code>js.esm-eval-returns-exports</code> option, with this option enabled, we can import a ECMAScript module by loading the source file. However, it will take some time to write support for things like <code>exports</code> fields in <code>package.json</code>.\n</p>\n</div>\n</div>\n<div id=\"outline-container-using-javascript-array-in-clojure\" class=\"outline-3\">\n<a href=\"#using-javascript-array-in-clojure\"><h3 id=\"using-javascript-array-in-clojure\" class=\"cr-self-reference \">Using JavaScript array in Clojure</h3></a>\n<div class=\"outline-text-3\" id=\"text-using-javascript-array-in-clojure\">\n<p>\nIn ClojureScript, many times we can use a JavaScript array just like a ClojureScript vector (not vice versa though).\nWe haven't implement something similar to this.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body><span class=\"hljs-comment\">;; ClojureScript</span>\n(<span class=\"hljs-name\"><span class=\"hljs-built_in\">map</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">fn</span></span> [x] (<span class=\"hljs-name\"><span class=\"hljs-built_in\">*</span></span> x <span class=\"hljs-number\">2</span>)) #js [<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span>])\n<span class=\"hljs-comment\">;; (2 4 6)</span>\n</body></html></code></pre>\n</div>\n</div>\n</div>\n</div>\n<div id=\"outline-container-to-be-continue...\" class=\"outline-2\">\n<a href=\"#to-be-continue...\"><h2 id=\"to-be-continue...\" class=\"cr-self-reference \">To Be Continueâ€¦</h2></a>\n<div class=\"outline-text-2\" id=\"text-to-be-continue...\">\n<p>\nDespite the limitations, I still believe this approach is something worth exploring. I'm planning on making an isomorphic React demonstration with Server Side Rendering and Client Side Rehydration using only a thin wrapper over React and React DOM Server (instead of reimplementing the SSR logics on the JVM). The code presented here is also expanded and refined when I'm writing the blog, and the code is open sourced at <a href=\"https://github.com/imakira/js4clj\">imakira/js4clj</a>.\n</p>\n</div>\n</div>\n","published-date":"2025-11-18T15:03:31+08:00","title":"Experiment with GraalVM, Clojure, and JavaScript","show-toc?":true,"author":null,"language":"en_US","id":"experiment-with-graalvm--clojure--and-javascript","file-path":"/home/void/Projects/imakira.github.io/blogs/experiment-with-graalvm-clojure-and-javascript.org","modified-date":"2025-11-18T15:03:31+08:00"}