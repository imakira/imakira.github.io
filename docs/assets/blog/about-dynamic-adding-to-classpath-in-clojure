{"blog/orgx":true,"blog/tags":[],"blog/unlisted":false,"blog/title":"About Dynamic Adding to Classpath in Clojure","blog/show-toc?":true,"blog/file-path":"/home/void/Projects/cerulean/workspace/blogs/class-path.org","blog/author":null,"blog/email":null,"blog/description":"Well, I guess people will just inevitably get into the problem of  classpath , one way or another.  The Classpath is a Lie  described the problem very well...","blog/id":"about-dynamic-adding-to-classpath-in-clojure","blog/category":"Coding","blog/language":"en_US","blog/published-date":"2026-01-25T00:00:00+08:00","blog/content":"<p>\nWell, I guess people will just inevitably get into the problem of <code>classpath</code>, one way or another. <a href=\"https://lambdaisland.com/blog/2021-08-25-classpath-is-a-lie\">The Classpath is a Lie</a> described the problem very well: <i>classpath is a lie</i>. <code>classpath</code>, <i>per se</i>, is a simple list separated by colons, however, the real work is done by the <code>Classloader</code>.\n</p>\n\n<p>\nNevertheless, this isn't a post talking about <code>classpath</code> and <code>ClassLoader</code>. There are already a lot of great articles talking about it (<a href=\"#links\">links</a> at the end of this post), and I can't claim I understand <code>ClassLoaders</code> to the extent that I can confidently teach others about it either.\n</p>\n\n<p>\nThis is a blog about what I have found during the process of trying to add new directories to <code>classpath</code> and <code>require</code> Clojure files in them at runtime. <code>ClassLoader</code> in Clojure is something very messy. The best strategy probably is to avoid the problem altogether. But still, if you really want to do it, I wish the following content can offer some help.\n</p>\n<div id=\"outline-container-use-builtin-~clojure.core/add-classpath~\" class=\"outline-2\">\n<a href=\"#use-builtin-~clojure.core/add-classpath~\"><h2 id=\"use-builtin-~clojure.core/add-classpath~\" class=\"cr-self-reference \">Use Builtin <code>clojure.core/add-classpath</code></h2></a>\n<div class=\"outline-text-2\" id=\"text-use-builtin-~clojure.core/add-classpath~\">\n<p>\n<code>Clojure</code> has a builtin <code>add-classpath</code> function. Although it has been deprecated, it works for simple use cases.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defn</span> <span class=\"hljs-title\">check-dynamic-load</span> []\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [tmp-dir (<span class=\"hljs-name\">.toFile</span> (<span class=\"hljs-name\">Files/createTempDirectory</span> <span class=\"hljs-string\">&quot;classpath-demo&quot;</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> java.nio.file.attribute.FileAttribute [])))\n        tmp-clj (<span class=\"hljs-name\">File/createTempFile</span> <span class=\"hljs-string\">&quot;demo&quot;</span> <span class=\"hljs-string\">&quot;.clj&quot;</span> tmp-dir)\n        tmp-name (<span class=\"hljs-name\">subs</span> (<span class=\"hljs-name\">.getName</span> tmp-clj)\n                       <span class=\"hljs-number\">0</span>\n                       (<span class=\"hljs-name\">.lastIndexOf</span> (<span class=\"hljs-name\">.getName</span> tmp-clj)\n                                     <span class=\"hljs-string\">&quot;.&quot;</span>))]\n    <span class=\"hljs-comment\">;; Add `tmp-dir` to `classpath` using builtin `add-classpath`.</span>\n    (<span class=\"hljs-name\">add-classpath</span> (<span class=\"hljs-name\">.toURL</span> tmp-dir))\n\n    <span class=\"hljs-comment\">;; Put a Clojure file under the directory</span>\n    (<span class=\"hljs-name\">spit</span> tmp-clj\n          (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> <span class=\"hljs-string\">&quot;(ns &quot;</span> tmp-name <span class=\"hljs-string\">&quot;) (def a 1)&quot;</span>))\n                                        <span class=\"hljs-comment\">;</span>\n    <span class=\"hljs-comment\">;; `require` the Clojure file, and resolve the variable</span>\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">assert</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">=</span></span> <span class=\"hljs-number\">1</span> (<span class=\"hljs-name\">var-get</span> (<span class=\"hljs-name\">requiring-resolve</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">symbol</span></span> tmp-name\n                                                     <span class=\"hljs-string\">&quot;a&quot;</span>)))))\n\n    <span class=\"hljs-comment\">;; Update the Clojure file</span>\n    (<span class=\"hljs-name\">spit</span> tmp-clj\n          (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> <span class=\"hljs-string\">&quot;(ns &quot;</span> tmp-name <span class=\"hljs-string\">&quot;) (def a 2)&quot;</span>))\n\n    <span class=\"hljs-comment\">;; Reload the Clojure file</span>\n    (<span class=\"hljs-name\">require</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">symbol</span></span> tmp-name)\n             <span class=\"hljs-symbol\">:reload-all</span>)\n\n    <span class=\"hljs-comment\">;; We can read the new value</span>\n    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">assert</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">=</span></span> <span class=\"hljs-number\">2</span> (<span class=\"hljs-name\">var-get</span> (<span class=\"hljs-name\">requiring-resolve</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">symbol</span></span> tmp-name\n                                                     <span class=\"hljs-string\">&quot;a&quot;</span>)))))\n    (<span class=\"hljs-name\">println</span> <span class=\"hljs-string\">&quot;success&quot;</span>)))\n\n<span class=\"hljs-comment\">;; success</span>\n(<span class=\"hljs-name\">check-dynamic-load</span>)\n</body></html></code></pre>\n</div>\n\n<p>\nIf we evaluate the above code in a REPL or in cider, it works and prints &quot;success&quot;. As we can see from the code, we can <code>require</code> a Clojure file whose path determined at runtime, and reload it to get the updated value.\n</p>\n\n<p>\nHowever, there is a reason of it being deprecated. We can check its source code:\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-java\"><html><head></head><body><span class=\"hljs-comment\">// The method used by clojure.core/add-classpath</span>\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">addURL</span><span class=\"hljs-params\">(Object url)</span> <span class=\"hljs-keyword\">throws</span> MalformedURLException{\n      <span class=\"hljs-type\">URL</span> <span class=\"hljs-variable\">u</span> <span class=\"hljs-operator\">=</span> (url <span class=\"hljs-keyword\">instanceof</span> String) ? toUrl((String) url) : (URL) url;\n      <span class=\"hljs-type\">ClassLoader</span> <span class=\"hljs-variable\">ccl</span> <span class=\"hljs-operator\">=</span> Thread.currentThread().getContextClassLoader();\n      <span class=\"hljs-keyword\">if</span>(ccl <span class=\"hljs-keyword\">instanceof</span> DynamicClassLoader)\n              ((DynamicClassLoader)ccl).addURL(u);\n      <span class=\"hljs-keyword\">else</span>\n              <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IllegalAccessError</span>(<span class=\"hljs-string\">&quot;Context classloader is not a DynamicClassLoader&quot;</span>);\n}\n</body></html></code></pre>\n</div>\n\n<p>\nIt checks if the current thread's <code>ContextClassLoader</code> is a <code>DynamicClassLoader</code>. If so, it will call the <code>DynamicClassLoader</code>'s <code>addURL</code> method.\nThat means, this method will fail if there's some code set the current <code>ContextClassLoader</code> to something other than a <code>DynamicClassLoader</code>.\n</p>\n\n<pre class=\"orgx\" data-wrapper=\"use-comp\" data-wrapper-data=\"note\"><p>\nWe expect <code>add-classpath</code> continues to work in case because the convention of setting a new <code>ClassLoader</code> is to set the current <code>ClassLoader</code> as the parent of the newly created <code>ClassLoader</code>. However, <code>clojure.core/add-classpath</code> only checks the current <code>ClassLoader</code>, more on this in the section.\n</p>\n\n</pre>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [future\n      (<span class=\"hljs-name\"><span class=\"hljs-built_in\">future</span></span>\n        (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [cl (<span class=\"hljs-name\">.getContextClassLoader</span> (<span class=\"hljs-name\">Thread/currentThread</span>))]\n          (<span class=\"hljs-name\">.setContextClassLoader</span> (<span class=\"hljs-name\">Thread/currentThread</span>)\n                                  (<span class=\"hljs-name\">java.net.URLClassLoader.</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> java.net.URL [])\n                                                            cl)))\n            (<span class=\"hljs-name\"><span class=\"hljs-built_in\">try</span></span> (<span class=\"hljs-name\">check-dynamic-load</span>)\n             (<span class=\"hljs-name\"><span class=\"hljs-built_in\">assert</span></span> <span class=\"hljs-string\">&quot;unreachable&quot;</span>)\n             (<span class=\"hljs-name\">catch</span> Throwable t\n               (<span class=\"hljs-name\">println</span> <span class=\"hljs-string\">&quot;dynamic loading failed&quot;</span>))))]\n  <span class=\"hljs-comment\">;; &quot;dynamic loading failed&quot;</span>\n  @future)\n</body></html></code></pre>\n</div>\n</div>\n</div>\n<div id=\"outline-container-use-~add-classpath~-from-~pomegranate~\" class=\"outline-2\">\n<a href=\"#use-~add-classpath~-from-~pomegranate~\"><h2 id=\"use-~add-classpath~-from-~pomegranate~\" class=\"cr-self-reference \">Use <code>add-classpath</code> from <code>pomegranate</code></h2></a>\n<div class=\"outline-text-2\" id=\"text-use-~add-classpath~-from-~pomegranate~\">\n<p>\n<a href=\"https://github.com/clj-commons/pomegranate\">pomegranate</a> provides a <code>add-classpath</code> that solves the problem described in the previous section.\n</p>\n\n<p>\nThe only thing we need to change is to replace <code>clojure.core/add-classpath</code> with <code>cemerick.pomegranate/add-classpath</code>.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-name\"><span class=\"hljs-built_in\">ns</span></span> demo\n  (<span class=\"hljs-symbol\">:require</span>\n   [cemerick.pomegranate <span class=\"hljs-symbol\">:as</span> pomegranate]))\n\n(<span class=\"hljs-keyword\">defn</span> <span class=\"hljs-title\">check-dynamic-load-using-pomegranate</span> []\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [<span class=\"hljs-comment\">;; ...</span>\n        ]\n    <span class=\"hljs-comment\">;; same code as `check-dynamic-load`</span>\n    (<span class=\"hljs-name\">pomegranate/add-classpath</span> (<span class=\"hljs-name\">.toURL</span> tmp-dir))\n    <span class=\"hljs-comment\">;; same code as `check-dynamic-load`</span>\n    ))\n\n(<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [future\n      (<span class=\"hljs-name\"><span class=\"hljs-built_in\">future</span></span>\n        (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [cl (<span class=\"hljs-name\">.getContextClassLoader</span> (<span class=\"hljs-name\">Thread/currentThread</span>))]\n          (<span class=\"hljs-name\">.setContextClassLoader</span> (<span class=\"hljs-name\">Thread/currentThread</span>)\n                                  (<span class=\"hljs-name\">java.net.URLClassLoader.</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">into-array</span></span> java.net.URL [])\n                                                            cl)))\n        (<span class=\"hljs-name\">check-dynamic-load-using-pomegranate</span>)\n        (<span class=\"hljs-name\">print</span> <span class=\"hljs-string\">&quot;success&quot;</span>))]\n  <span class=\"hljs-comment\">;; success</span>\n  @future)\n</body></html></code></pre>\n</div>\n\n<p>\nUnlike <code>add-classpath</code> from <code>clojure.core</code>, <code>pomegranate</code>'s <code>add-classpath</code> try to find the <code>ClassLoader</code> closest to the <i>Primordial ClassLoader</i> that is compatible with <code>add-classpath</code>, and call the <code>addURL</code> method from it.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body><span class=\"hljs-comment\">;; in `add-classpath` function in pomegranate.clj  </span>\n(<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [classloaders (<span class=\"hljs-name\">classloader-hierarchy</span>)]\n      (<span class=\"hljs-name\"><span class=\"hljs-built_in\">if-let</span></span> [cl (<span class=\"hljs-name\"><span class=\"hljs-built_in\">last</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">filter</span></span> modifiable-classloader? classloaders))]\n        (<span class=\"hljs-name\">add-classpath</span> jar-or-dir cl)\n        (<span class=\"hljs-name\"><span class=\"hljs-built_in\">throw</span></span> (<span class=\"hljs-name\">IllegalStateException.</span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">str</span></span> <span class=\"hljs-string\">&quot;Could not find a suitable classloader to modify from &quot;</span>\n                                            (<span class=\"hljs-name\"><span class=\"hljs-built_in\">mapv</span></span> (<span class=\"hljs-name\"><span class=\"hljs-built_in\">fn</span></span> [^ClassLoader c]\n                                                    (<span class=\"hljs-name\"><span class=\"hljs-built_in\">-&gt;</span></span> c .getClass .getSimpleName))\n                                                  classloaders))))))\n</body></html></code></pre>\n</div>\n</div>\n</div>\n<div id=\"outline-container-create-a-~dynamicclassloader~-when-there-isn't-one\" class=\"outline-2\">\n<a href=\"#create-a-~dynamicclassloader~-when-there-isn't-one\"><h2 id=\"create-a-~dynamicclassloader~-when-there-isn't-one\" class=\"cr-self-reference \">Create a <code>DynamicClassLoader</code> When There isn't One</h2></a>\n<div class=\"outline-text-2\" id=\"text-create-a-~dynamicclassloader~-when-there-isn't-one\">\n<p>\nIf you are running Clojure in REPL or with <code>nrepl</code>, the <code>ContextClassLoader</code> of the current thread will certainly be <code>DynamicClassLoader</code>, set by one of those tools. However, when you run <code>clj</code> command in a non-interactive manner, or use a AOT-compiled jar file, this wouldn't be the case.\n</p>\n\n<p>\nThis problem is quite easy to solve, we just need to set the <code>ContextClassLoader</code> to a <code>DynamicClassLoader</code> created by ourselves in the entrypoint of the program.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-keyword\">defn</span> <span class=\"hljs-title\">-main</span> [&amp; args]\n  (<span class=\"hljs-name\"><span class=\"hljs-built_in\">let</span></span> [cl (<span class=\"hljs-name\">.getContextClassLoader</span> (<span class=\"hljs-name\">Thread/currentThread</span>))]\n    (<span class=\"hljs-name\">.setContextClassLoader</span> (<span class=\"hljs-name\">Thread/currentThread</span>) (<span class=\"hljs-name\">clojure.lang.DynamicClassLoader.</span> cl)))\n  <span class=\"hljs-comment\">;; other code...</span>\n  )\n</body></html></code></pre>\n</div>\n</div>\n</div>\n<div id=\"outline-container-when-using-~kaocha~\" class=\"outline-2\">\n<a href=\"#when-using-~kaocha~\"><h2 id=\"when-using-~kaocha~\" class=\"cr-self-reference \">When Using <code>kaocha</code></h2></a>\n<div class=\"outline-text-2\" id=\"text-when-using-~kaocha~\">\n<p>\nSo far, so good. Except when you finish the code and try to test some code and run it under the <a href=\"https://github.com/lambdaisland/kaocha\">kaocha</a> test runner. <code>kaocha</code> also did its own thing with <code>ClassLoader</code> and provides a <code>add-classpath</code> method. It breaks the previous method.\n</p>\n\n<p>\nBy detecting <code>kaocha</code>'s presence and calling its <code>add-classpath</code>, alongside with the <code>pomegranate</code> one solves the issue for me.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-name\"><span class=\"hljs-built_in\">when</span></span> (<span class=\"hljs-name\">find-ns</span> 'kaocha.classpath)\n  ((<span class=\"hljs-name\"><span class=\"hljs-built_in\">intern</span></span> 'kaocha.classpath\n           'add-classpath)\n   new-path))\n</body></html></code></pre>\n</div>\n</div>\n</div>\n<div id=\"outline-container-pitfall-when-using-a-threadpool\" class=\"outline-2\">\n<a href=\"#pitfall-when-using-a-threadpool\"><h2 id=\"pitfall-when-using-a-threadpool\" class=\"cr-self-reference \">Pitfall When Using a Threadpool</h2></a>\n<div class=\"outline-text-2\" id=\"text-pitfall-when-using-a-threadpool\">\n<p>\nWhen you create a thread, the new thread will inherit the <code>ContextClassLoader</code> of the thread created it. However when you explicitly or implicitly (like when using <code>future</code>) use a threadpool, the executor may choose an existing thread, which could have a <code>ContextClassLoader</code> different from the calling thread.\n</p>\n\n<p>\nYou may consider creating a thread directly instead of relying on <code>future</code> in this case.\n</p>\n\n<div class=\"org-src-container\">\n<pre class=\"cr-highlighted\"><code class=\"lang-clojure\"><html><head></head><body>(<span class=\"hljs-name\"><span class=\"hljs-built_in\">doto</span></span> (<span class=\"hljs-name\">Thread/new</span>\n       (<span class=\"hljs-name\">bound-fn</span> []\n         <span class=\"hljs-comment\">;; code</span>\n         ))\n  (<span class=\"hljs-name\">.start</span>))\n</body></html></code></pre>\n</div>\n</div>\n</div>\n<div id=\"outline-container-a-few-more-words\" class=\"outline-2\">\n<a href=\"#a-few-more-words\"><h2 id=\"a-few-more-words\" class=\"cr-self-reference \">A Few More Words</h2></a>\n<div class=\"outline-text-2\" id=\"text-a-few-more-words\">\n<p>\nThis post is definitely not comprehensive, and there are still a lot things I currently do not understand. The method I have described works for me for now. If you want to understand more about this topic, I have listed a few links below.\n</p>\n</div>\n</div>\n<div id=\"outline-container-links\" class=\"outline-2\">\n<a href=\"#links\"><h2 id=\"links\" class=\"cr-self-reference \">Links</h2></a>\n<div class=\"outline-text-2\" id=\"text-links\">\n<ol class=\"org-ol\">\n<li><a href=\"https://www.infoworld.com/article/2171026/find-a-way-out-of-the-classloader-maze.html\">Find a way out of the ClassLoader maze</a> (2003)</li>\n<li><a href=\"https://danielsz.github.io/2021-05-12T13_24.html\">Once Upon a Class</a></li>\n<li><a href=\"https://lambdaisland.com/blog/2021-08-25-classpath-is-a-lie\">The Classpath is a Lie</a></li>\n</ol>\n</div>\n</div>\n","blog/orgx-require":null,"blog/modified-date":"2026-01-26T05:09:29+08:00"}